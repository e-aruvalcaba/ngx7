import { __awaiter } from 'tslib';
import { Router } from '@angular/router';
import { Headers, Http, RequestOptions, Response } from '@angular/http';
import { Observable, BehaviorSubject, throwError, Subject } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { SessionServiceConstants, EndpointsConstants } from '@cemex-core/constants-v2/dist';
import { Broadcaster } from '@cemex-core/events-v7';
import { Injectable, Inject, Optional, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProjectSettings {
    constructor() {
        /** @type {?} */
        const APP_KEYS = {
            API_ENV_KEY: 'API_ENV',
            API_HOST_KEY: 'API_HOST',
            API_ORG_KEY: 'API_ORG',
            APP_CODE_KEY: 'APP_CODE',
            CLIENT_ID_KEY: 'CLIENT_ID'
        };
        this._appCode = ((/** @type {?} */ (global)))[APP_KEYS.APP_CODE_KEY];
        this._clientId = ((/** @type {?} */ (global)))[APP_KEYS.CLIENT_ID_KEY];
        this._apiBasePath = ((/** @type {?} */ (global)))[APP_KEYS.API_HOST_KEY];
        this._apiOrg = ((/** @type {?} */ (global)))[APP_KEYS.API_ORG_KEY];
        this._apiEnv = ((/** @type {?} */ (global)))[APP_KEYS.API_ENV_KEY];
        if (this._apiBasePath === undefined) {
            console.warn('environment variable \'API_HOST\' is missing !!');
        }
    }
    // ============================================================================================
    // Getters
    // ============================================================================================
    /**
     * @return {?}
     */
    get appCode() {
        return this._appCode;
    }
    /**
     * @return {?}
     */
    get clientId() {
        return this._clientId;
    }
    /**
     * @return {?}
     */
    get apiBasePath() {
        return this._apiBasePath;
    }
    /**
     * @return {?}
     */
    get apiOrg() {
        return this._apiOrg;
    }
    /**
     * @return {?}
     */
    get apiEnv() {
        return this._apiEnv;
    }
    /**
     * @param {?} apiEndpoint
     * @return {?}
     */
    generateEndpoint(apiEndpoint) {
        /** @type {?} */
        const url = `${this._apiBasePath}${this._apiOrg}${this._apiEnv}${apiEndpoint}`;
        return url;
    }
    /**
     * @return {?}
     */
    getBaseOrgEnvPath() {
        return this._apiBasePath + this._apiOrg + this._apiEnv;
    }
    /**
     * @param {?} newKeys
     * @return {?}
     */
    setAppKeys(newKeys) {
        this._appCode = newKeys.APP_CODE;
        this._clientId = newKeys.CLIENT_ID;
        if (this._apiBasePath === undefined) {
            console.warn('environment variable \'API_HOST\' is missing !!');
        }
    }
}
ProjectSettings.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProjectSettings.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpCemex {
    /**
     * @param {?} http
     * @param {?} projectSettings
     */
    constructor(http, projectSettings) {
        this.http = http;
        this.projectSettings = projectSettings;
        this._validSettings = false;
        this._validSettings = this.validateProjectSettings();
    }
    /**
     * @param {?} apiEndpoint
     * @return {?}
     */
    generateEndpoint(apiEndpoint) {
        return this.projectSettings.generateEndpoint(apiEndpoint);
    }
    /**
     * @return {?}
     */
    get clientId() {
        return this.projectSettings.clientId;
    }
    /**
     * @return {?}
     */
    get appCode() {
        return this.projectSettings.appCode;
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    request(url, options) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options);
        return this.http.request(url, loptions);
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    get(url, options, overrideHeader) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.get(url, loptions);
    }
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    post(url, body, options, overrideHeader) {
        if (!this._validSettings) {
            /** @type {?} */
            const message = 'Set missing environment variables of API_HOST, API_ORG, API_ENV, APP_CODE, CLIENT_ID';
            return Observable.throw(new Error(message));
        }
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.post(url, body, loptions);
    }
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    put(url, body, options, overrideHeader) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.put(url, body, loptions);
    }
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    patch(url, body, options, overrideHeader) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.patch(url, body, loptions);
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    delete(url, options, overrideHeader) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.delete(url, loptions);
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    head(url, options, overrideHeader) {
        /** @type {?} */
        const loptions = this.createAuthorizationHeader(options, overrideHeader);
        return this.http.head(url, loptions);
    }
    /**
     * @return {?}
     */
    isRunningOnBrowser() {
        return ((/** @type {?} */ (global))) !== null && ((/** @type {?} */ (global))) !== undefined;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    encrypt(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
    }
    /**
     * @param {?} str
     * @return {?}
     */
    decrypt(str) {
        return str ? decodeURIComponent(escape(window.atob(str))) : str;
    }
    /**
     * @param {?} newKeys
     * @return {?}
     */
    setProjectSettingsNewKeys(newKeys) {
        this.projectSettings.setAppKeys(newKeys);
    }
    /**
     * @protected
     * @param {?} options
     * @param {?=} overrideHeader
     * @return {?}
     */
    createAuthorizationHeader(options, overrideHeader) {
        /** @type {?} */
        const containsHeader = options && options.headers && options.headers.keys().length > 0;
        /** @type {?} */
        const result = options
            ? Object.assign({}, options)
            : new RequestOptions();
        /** @type {?} */
        const headers = new Headers();
        /** @type {?} */
        const language = this.isRunningOnBrowser()
            ? ((/** @type {?} */ (window))).localStorage.getItem('language') || 'en'
            : 'en';
        headers.append('Accept', 'application/json');
        headers.append('X-IBM-Client-Id', this.projectSettings.clientId);
        headers.append('App-Code', this.projectSettings.appCode);
        headers.append('Accept-Language', language);
        /** @type {?} */
        const accessToken = sessionStorage.getItem('access_token');
        /** @type {?} */
        const isContainsToken = accessToken && accessToken !== undefined;
        if (isContainsToken) {
            headers.append('Authorization', 'Bearer ' + accessToken);
        }
        /** @type {?} */
        const jwtApp = sessionStorage.getItem('jwt');
        if (this.isRunningOnBrowser() && jwtApp && jwtApp !== undefined) {
            headers.append('jwt', jwtApp);
        }
        // overwrite existing headers or add new headers
        /** @type {?} */
        const headerKeys = containsHeader ? options.headers.keys() : [];
        for (const keyHeader of headerKeys) {
            headers.set(keyHeader, options.headers.get(keyHeader));
        }
        result.headers = headers;
        if (overrideHeader && containsHeader) {
            result.headers = options.headers;
        }
        return result;
    }
    /**
     * @private
     * @return {?}
     */
    validateProjectSettings() {
        /** @type {?} */
        const settings = this.projectSettings;
        return (settings.apiBasePath !== undefined &&
            settings.apiEnv !== undefined &&
            settings.apiOrg !== undefined &&
            settings.appCode !== undefined &&
            settings.clientId !== undefined);
    }
}
HttpCemex.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpCemex.ctorParameters = () => [
    { type: Http },
    { type: ProjectSettings }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SessionService {
    /**
     * @param {?} http
     * @param {?} eventBroadcaster
     * @param {?} authTokenVersion
     */
    constructor(http, eventBroadcaster, authTokenVersion) {
        this.http = http;
        this.eventBroadcaster = eventBroadcaster;
        this.authTokenVersion = authTokenVersion;
        this.siteDomain = 'SITE_DOMAIN';
        this._siteDomain = window[this.siteDomain] || '';
        this._menuApplication = new BehaviorSubject([]);
        this._currentLegalEntity = new BehaviorSubject(null);
        this._userProfile = null;
        this._beforeLogout = null;
        if (authTokenVersion) {
            switch (authTokenVersion.toLocaleLowerCase()) {
                case 'v6':
                    this._endpoint = SessionServiceConstants.LOGIN_TOKEN_V6;
                    break;
                default:
                    this._endpoint = SessionServiceConstants.LOGIN_TOKEN_DEFAULT;
            }
        }
        else {
            this._endpoint = SessionServiceConstants.LOGIN_TOKEN_DEFAULT;
        }
        if (localStorage.getItem('language') === undefined ||
            (localStorage.getItem('language') === null &&
                (sessionStorage.getItem('language') !== undefined && sessionStorage.getItem('language') !== null))) {
            localStorage.setItem('language', sessionStorage.getItem('language'));
        }
    }
    /**
     * @return {?}
     */
    get menuApplicationItems() {
        if (this._menuApplication.getValue().length === 0) {
            this.reloadAppMenuItems();
        }
        return this._menuApplication.asObservable();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setLegalEntity(value) {
        sessionStorage.setItem('user_legal_entity', JSON.stringify(value));
        this.eventBroadcaster.broadcast(Broadcaster.DCM_LEGAL_ENTITY_CHANGE, JSON.stringify(value));
        this._currentLegalEntity.next(value);
    }
    /**
     * @return {?}
     */
    get currentLegalEntity() {
        return this._currentLegalEntity.asObservable();
    }
    /**
     * @return {?}
     */
    get isLoggedIn() {
        /** @type {?} */
        const accessToken = sessionStorage.getItem('access_token');
        /** @type {?} */
        const jwtToken = sessionStorage.getItem('jwt');
        return (accessToken !== null &&
            accessToken !== undefined &&
            accessToken !== '' &&
            jwtToken != null &&
            jwtToken !== undefined &&
            jwtToken !== '');
    }
    /**
     * @return {?}
     */
    logout() {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            if (this._beforeLogout) {
                this._beforeLogout.subscribe((/**
                 * @param {?} result
                 * @return {?}
                 */
                result => {
                    this.logoutApp();
                    observer.next({
                        message: 'success',
                        success: true
                    });
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    observer.next({
                        message: error,
                        success: false
                    });
                }));
            }
            else {
                this.logoutApp();
                observer.next({
                    message: 'success',
                    success: true
                });
            }
            return observer;
        }));
    }
    /**
     * @param {?} user
     * @param {?} password
     * @param {?=} generateCookie
     * @param {?=} appName
     * @param {?=} validateTempPassword
     * @return {?}
     */
    login(user, password, generateCookie, appName, validateTempPassword) {
        this.clean();
        /** @type {?} */
        const options = new RequestOptions({
            headers: new Headers({
                'Content-Type': 'application/x-www-form-urlencoded',
                accept: 'text/plain, */*'
            })
        });
        /** @type {?} */
        const endpoint = this.http.generateEndpoint(this._endpoint);
        /** @type {?} */
        const urlPost = this.generateUrlString(user, password, appName);
        return this.http
            .post(endpoint, urlPost, options)
            .toPromise()
            .then((/**
         * @param {?} response
         * @return {?}
         */
        (response) => __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const data = response.json();
            /** @type {?} */
            const userId = this.authTokenVersion === 'v6'
                ? data.userId
                    ? data.userId
                    : data.profile.userId
                : data.profile.userId;
            this.processDataFromLogin(data, generateCookie);
            this.eventBroadcaster.broadcast(SessionService.LOGIN_SUCCESS_EVENT);
            if (validateTempPassword &&
                data.profile &&
                data.profile.hasTemporaryPassword) {
                return Promise.resolve(data);
            }
        })))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            console.error(error);
            this.eventBroadcaster.broadcast(SessionService.LOGIN_FAIL_EVENT);
            return Promise.reject(error);
        }));
    }
    /**
     * @return {?}
     */
    get userRegion() {
        return sessionStorage.getItem('region') || 'US';
    }
    /**
     * @return {?}
     */
    get userCountry() {
        return sessionStorage.getItem('country') || '';
    }
    /**
     * @return {?}
     */
    get userProfile() {
        if (!this._userProfile) {
            this.setUserProfile();
        }
        return this._userProfile;
    }
    /**
     * @param {?=} fetch
     * @param {?=} page
     * @param {?=} legalEntityCode
     * @return {?}
     */
    getLegalEntities(fetch, page, legalEntityCode) {
        /** @type {?} */
        let endpoint = this.http.generateEndpoint(SessionServiceConstants.USER_LEGAL_ENTITIES);
        endpoint = this.addQueryParams(endpoint, fetch, page, legalEntityCode);
        return this.http.get(endpoint).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            let responseMap = [];
            /** @type {?} */
            const tmpJson = response.json();
            if (tmpJson) {
                responseMap = response.json();
            }
            return responseMap;
        })), catchError((/**
         * @param {?} e
         * @return {?}
         */
        e => Observable.throw(this.handleError(e)))));
    }
    /**
     * @param {?} method
     * @return {?}
     */
    setBeforeLogout(method) {
        this._beforeLogout = method;
    }
    /**
     * @return {?}
     */
    getBeforeLogout() {
        return this._beforeLogout;
    }
    /**
     * @return {?}
     */
    reloadAppMenuItems() {
        this.getDCMApplications().subscribe((/**
         * @param {?} result
         * @return {?}
         */
        result => {
            this._menuApplication.next(result);
        }));
    }
    /**
     * @param {?} name
     * @param {?} value
     * @param {?=} days
     * @return {?}
     */
    createCookie(name, value, days) {
        /** @type {?} */
        let expires = '';
        if (days) {
            /** @type {?} */
            const date = new Date();
            date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
            expires = date.toUTCString();
        }
        else {
            days = 0;
        }
        /** @type {?} */
        const cookie = `${name}=${value};expires=${expires};domain=${this._siteDomain};path=/`;
        document.cookie = cookie;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    readCookie(name) {
        /** @type {?} */
        const ca = document.cookie.split(';');
        /** @type {?} */
        const caLen = ca.length;
        /** @type {?} */
        const cookieName = `${name}=`;
        /** @type {?} */
        let c;
        for (let i = 0; i < caLen; i += 1) {
            c = ca[i].replace(/^\s+/g, '');
            if (c.indexOf(cookieName) === 0) {
                return c.substring(cookieName.length, c.length);
            }
        }
        return null;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    clearCookie(name) {
        this.createCookie(name, '', -1);
    }
    /**
     * @return {?}
     */
    setUserProfile() {
        /** @type {?} */
        const strProfile = sessionStorage.getItem('user_profile');
        /** @type {?} */
        const tmpProfile = this.convertJsonTo(strProfile);
        if (tmpProfile) {
            /** @type {?} */
            const strCustomer = sessionStorage.getItem('user_customer');
            /** @type {?} */
            const userCustomer = this.convertJsonTo(strCustomer);
            if (userCustomer) {
                tmpProfile.customer = userCustomer;
            }
            else {
                console.warn('Exception at parsing User Customer from sessionStore');
            }
            this._userProfile = tmpProfile;
        }
        else {
            console.warn('Exception at parsing User Profile from sessionStore');
        }
    }
    /**
     * @return {?}
     */
    clean() {
        this.clearCookie('CemexGoRegion');
        this.clearCookie('up_session');
        sessionStorage.removeItem('access_token');
        sessionStorage.removeItem('refresh_token');
        sessionStorage.removeItem('expires_in');
        sessionStorage.removeItem('jwt');
        sessionStorage.removeItem('region');
        sessionStorage.removeItem('user_profile');
        sessionStorage.removeItem('user_customer');
        sessionStorage.removeItem('user_legal_entity');
        sessionStorage.removeItem('user_applications');
        // patch-fix for react
        sessionStorage.removeItem('auth_token');
        sessionStorage.removeItem('userInfo');
        sessionStorage.removeItem('country');
        sessionStorage.removeItem('token_data');
        sessionStorage.removeItem('applications');
        sessionStorage.removeItem('role');
        sessionStorage.removeItem('username');
        // new verssion API ( v6 )
        sessionStorage.removeItem('userAuthV6');
        sessionStorage.removeItem('userInfoV6');
        sessionStorage.removeItem('userProfileV6');
        sessionStorage.removeItem('userCustomerV6');
        sessionStorage.removeItem('userApplicationsV6');
        sessionStorage.removeItem('userRolesV6');
    }
    /**
     * @param {?} user
     * @param {?} password
     * @param {?=} appName
     * @return {?}
     */
    generateUrlString(user, password, appName) {
        /** @type {?} */
        const include = '&include=userinfo,profile,applications,roles,customers,oldVersion';
        /** @type {?} */
        let url = 'grant_type=password&scope=security&username=' +
            user +
            '&password=' +
            encodeURIComponent(password) +
            '&client_id=' +
            this.http.clientId;
        if (appName) {
            url = url + '&app_name=' + appName;
        }
        if (this.authTokenVersion) {
            if (this.authTokenVersion.toLowerCase() === 'v6') {
                url = `${url}&userinformation=false${include}`;
            }
        }
        return url;
    }
    /**
     * @param {?} data
     * @param {?=} generateCookie
     * @return {?}
     */
    processDataFromLogin(data, generateCookie) {
        // session cookie
        if (generateCookie) {
            /** @type {?} */
            const sessionCookie = {
                auth: data.oauth2.access_token,
                expires_in: data.oauth2.expires_in,
                jwt: data.jwt,
                refresh_token: data.oauth2.refresh_token,
                region: data.oauth2.region,
            };
            this.createCookie('up_session', JSON.stringify(sessionCookie), null);
        }
        this.createCookie('CemexGoRegion', data.oauth2.region, null);
        sessionStorage.setItem('access_token', data.oauth2.access_token);
        sessionStorage.setItem('refresh_token', data.oauth2.refresh_token);
        sessionStorage.setItem('expires_in', data.oauth2.expires_in);
        sessionStorage.setItem('jwt', data.jwt);
        sessionStorage.setItem('auth_token', data.oauth2.access_token);
        sessionStorage.setItem('user_profile', JSON.stringify(data.profile));
        sessionStorage.setItem('user_customer', JSON.stringify(data.customer));
        sessionStorage.setItem('user_applications', JSON.stringify(data.applications));
        // react
        sessionStorage.setItem('userInfo', JSON.stringify(data));
        sessionStorage.setItem('country', data.country);
        sessionStorage.setItem('token_data', JSON.stringify(data));
        sessionStorage.setItem('applications', JSON.stringify(data.applications));
        sessionStorage.setItem('region', data.oauth2.region);
        sessionStorage.setItem('role', data.role);
        sessionStorage.setItem('username', data.profile.userAccount);
        this.setUserProfile();
        // call API V6 ( New Model)
        /** @type {?} */
        const accessToKen = {
            oauth2: data.oauth2,
            // tslint:disable-next-line:object-literal-sort-keys
            jwt: data.jwt,
            userId: data.userId ? data.userId : data.profile.userId,
        };
        /** @type {?} */
        const encryptData = this.encrypt(JSON.stringify(accessToKen));
        sessionStorage.setItem('userAuthV6', encryptData);
        if (data._users) {
            /** @type {?} */
            const firstUser = data._users[0];
            /** @type {?} */
            const user = {
                accountType: firstUser.accountType,
                countryCode: firstUser.country.countryCode,
                customerId: (firstUser.customer) ? firstUser.customer.customerId : 0,
                firstName: firstUser.firstName,
                fullName: firstUser.fullName,
                lastName: firstUser.lastName,
                phoneNumber: firstUser.phoneNumber,
                userAccount: firstUser.userAccount,
                userId: firstUser.userId,
                userSelectedId: firstUser.userSelectedId,
                userStatus: firstUser.userStatus,
                userType: firstUser.userType,
            };
            /** @type {?} */
            const encryptUser = this.encrypt(JSON.stringify(user));
            sessionStorage.setItem('userInfoV6', encryptUser);
        }
        if (data._profile) {
            /** @type {?} */
            const dataProfile = data._profile;
            /** @type {?} */
            const profile = {
                allowEmailUpdates: dataProfile.allowEmailUpdates,
                allowInformationShare: dataProfile.allowInformationShare,
                hasTemporaryPassword: dataProfile.hasTemporaryPassword,
                userEmail: dataProfile.userEmail,
                userId: dataProfile.userId,
                userPosition: dataProfile.userPosition,
                userProfileId: dataProfile.userProfileId,
            };
            /** @type {?} */
            const encryptProfile = this.encrypt(JSON.stringify(profile));
            sessionStorage.setItem('userProfileV6', encryptProfile);
        }
        if (data._customers) {
            /** @type {?} */
            const dataCustomer = data._customers;
            /** @type {?} */
            const customer = {
                countryCode: dataCustomer.country.countryCode,
                customerCode: dataCustomer.customerCode,
                customerCodeLZR: dataCustomer.customerCodeLZR,
                customerDesc: dataCustomer.customerDesc,
                customerDesc2: dataCustomer.customerDesc2,
                customerId: dataCustomer.customerId,
                email: dataCustomer.email,
                faxNumber: dataCustomer.faxNumber,
                phoneNumber: dataCustomer.phoneNumber,
                regionId: dataCustomer.region.regionId,
                vAT: dataCustomer.vAT,
            };
            /** @type {?} */
            const encryptcustomer = this.encrypt(JSON.stringify(customer));
            sessionStorage.setItem('userCustomerV6', encryptcustomer);
        }
        if (data._applications) {
            /** @type {?} */
            const apps = data._applications.map((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                return {
                    applicationCode: app.applicationCode,
                    applicationId: app.applicationId,
                    applicationType: app.applicationType,
                    isVisible: app.isVisible,
                };
            }));
            /** @type {?} */
            const encryptApplications = this.encrypt(JSON.stringify(apps));
            sessionStorage.setItem('userApplicationsV6', encryptApplications);
        }
        if (data._roles) {
            /** @type {?} */
            const roles = data._roles.map((/**
             * @param {?} role
             * @return {?}
             */
            (role) => {
                return {
                    applicationId: role.application.applicationId,
                    isInternal: role.isInternal,
                    isOptional: role.isOptional,
                    isVisible: role.isVisible,
                    roleCode: role.roleCode,
                    roleId: role.roleId,
                    roleType: role.roleType,
                };
            }));
            /** @type {?} */
            const encryptRoles = this.encrypt(JSON.stringify(roles));
            sessionStorage.setItem('userRolesV6', encryptRoles);
        }
    }
    /**
     * @return {?}
     */
    getDCMApplications() {
        /** @type {?} */
        const endpoint = this.http.generateEndpoint(SessionServiceConstants.USER_APPLICATION_MENU);
        return this.http.get(endpoint).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const tmpJson = response.json();
            if (!tmpJson || tmpJson === undefined) {
                console.warn('Configuration of menu application is empty!!');
                return [];
            }
            /** @type {?} */
            const responseMap = (/** @type {?} */ (response.json()));
            return responseMap;
        })), catchError((/**
         * @param {?} e
         * @return {?}
         */
        (e) => Observable.throw(this.handleError(e)))));
    }
    /**
     * @template T
     * @param {?} obj
     * @return {?}
     */
    convertJsonTo(obj) {
        try {
            /** @type {?} */
            const tmpJson = JSON.parse(obj);
            return (/** @type {?} */ (tmpJson));
        }
        catch (e) {
            console.warn('Exception at parsing object from sessionStore:', e);
        }
        return null;
    }
    /**
     * @return {?}
     */
    get customer() {
        /** @type {?} */
        let result;
        /** @type {?} */
        const str = sessionStorage.getItem('user_customer');
        if (str) {
            try {
                /** @type {?} */
                const profile = JSON.parse(str);
                result = (/** @type {?} */ (profile));
            }
            catch (e) {
                console.warn('Exception at parsing user_customer from sessionStore:', e);
                return null;
            }
        }
        else {
            console.warn('There is no user customer at session storage');
        }
        return result;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // In a real world app, we might use a remote logging infrastructure
        /** @type {?} */
        let errMsg;
        if (error instanceof Response) {
            /** @type {?} */
            const body = error.json() || '';
            errMsg = `${error.status} - ${error.statusText || ''}`;
        }
        else {
            errMsg = error.message ? error.message : error.toString();
        }
        console.error(error);
        return throwError(error);
    }
    /**
     * @param {?} endpoint
     * @param {?=} fetch
     * @param {?=} page
     * @param {?=} legalEntityCode
     * @return {?}
     */
    addQueryParams(endpoint, fetch, page, legalEntityCode) {
        /** @type {?} */
        const validPagination = Number.isInteger(fetch) && Number.isInteger(page);
        endpoint += validPagination ? '?fetch=' + fetch + '&page=' + page : '';
        endpoint +=
            legalEntityCode && validPagination
                ? '&legalEntityCode=' + legalEntityCode
                : legalEntityCode && !validPagination
                    ? '?legalEntityCode=' + legalEntityCode
                    : '';
        return endpoint;
    }
    /**
     * @return {?}
     */
    logoutApp() {
        this.clean();
        this.eventBroadcaster.broadcast(Broadcaster.DCM_APP_LOGOUT);
    }
    /**
     * @return {?}
     */
    get userAuth() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userAuthV6')));
    }
    /**
     * @return {?}
     */
    get userInfo() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userInfoV6')));
    }
    /**
     * @return {?}
     */
    get userProfileV6() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userProfileV6')));
    }
    /**
     * @return {?}
     */
    get userCustomer() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userCustomerV6')));
    }
    /**
     * @return {?}
     */
    get userApplications() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userApplicationsV6')));
    }
    /**
     * @return {?}
     */
    get userRoles() {
        return JSON.parse(this.decrypt(sessionStorage.getItem('userRolesV6')));
    }
    /**
     * @param {?} str
     * @return {?}
     */
    encrypt(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
    }
    /**
     * @param {?} str
     * @return {?}
     */
    decrypt(str) {
        return str ? decodeURIComponent(escape(window.atob(str))) : str;
    }
}
SessionService.LOGIN_SUCCESS_EVENT = 'LOGIN_SUCCESS_EVENT';
SessionService.LOGIN_FAIL_EVENT = 'LOGIN_FAIL_EVENT';
SessionService.LOGIN_LOGOUT_EVENT = 'LOGIN_LOGOUT_EVENT';
SessionService.AUTH_TOKEN_VERSION = 'auth_token_version';
SessionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SessionService.ctorParameters = () => [
    { type: HttpCemex },
    { type: Broadcaster },
    { type: String, decorators: [{ type: Inject, args: [SessionService.AUTH_TOKEN_VERSION,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LegalEntity {
    /**
     * @param {?} http
     * @param {?} endpoints
     */
    constructor(http, endpoints) {
        this.http = http;
        this.endpoints = endpoints;
    }
    /**
     * @return {?}
     */
    getLegalEntity() {
        return this.http
            .get(this.getUrl('legalentity'))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            return aux;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @return {?}
     */
    getAllLegalEntityCustomers() {
        return this.http
            .get(this.getUrl('legalentitycustomers'))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.customer;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} customerCode
     * @return {?}
     */
    getLegalEntityByCustomer(customerCode) {
        return this.http
            .get(this.getUrl('legalentity?customerCode=' + customerCode))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.company;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} companyCode
     * @return {?}
     */
    getLegalEntityByCompany(companyCode) {
        return this.http
            .get(this.getUrl('legalentity?companyCode=' + companyCode))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.customer;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} customerCode
     * @param {?} companyCode
     * @return {?}
     */
    getLegalEntityJobsites(customerCode, companyCode) {
        /** @type {?} */
        const api = 'legalentityjobsites?companyCode=' +
            companyCode +
            '&customerCode=' +
            customerCode;
        return this.http
            .get(this.getUrl(api))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.jobSite;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} api
     * @return {?}
     */
    getUrl(api) {
        /** @type {?} */
        const url = this.http.generateEndpoint(this.endpoints.V1 + this.endpoints.armCapability + api);
        return url;
    }
}
LegalEntity.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LegalEntity.ctorParameters = () => [
    { type: HttpCemex },
    { type: EndpointsConstants }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FinancialDocuments {
    /**
     * @param {?} http
     * @param {?} endpoints
     */
    constructor(http, endpoints) {
        this.http = http;
        this.endpoints = endpoints;
    }
    /**
     * @return {?}
     */
    getLegalEntity() {
        return this.http
            .get(this.getUrl('legalentity'))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            return aux;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @return {?}
     */
    getAllLegalEntityCustomers() {
        return this.http
            .get(this.getUrl('legalentitycustomers'))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.customer;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} customerCode
     * @return {?}
     */
    getLegalEntityByCustomer(customerCode) {
        return this.http
            .get(this.getUrl('legalentity?customerCode=' + customerCode))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.company;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} companyCode
     * @return {?}
     */
    getLegalEntityByCompany(companyCode) {
        return this.http
            .get(this.getUrl('legalentity?companyCode=' + companyCode))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.customer;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @param {?} customerCode
     * @param {?} companyCode
     * @return {?}
     */
    getLegalEntityJobsites(customerCode, companyCode) {
        /** @type {?} */
        const api = 'legalentityjobsites?companyCode=' +
            companyCode +
            '&customerCode=' +
            customerCode;
        return this.http
            .get(this.getUrl(api))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            /** @type {?} */
            const snapshot = aux.responseLegalEntity.jobSite;
            return snapshot;
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @private
     * @param {?} api
     * @return {?}
     */
    getUrl(api) {
        /** @type {?} */
        const url = this.http.generateEndpoint(this.endpoints.V1 + this.endpoints.armCapability + api);
        return url;
    }
}
FinancialDocuments.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FinancialDocuments.ctorParameters = () => [
    { type: HttpCemex },
    { type: EndpointsConstants }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard {
    /**
     * @param {?} router
     * @param {?} sessionService
     */
    constructor(router, sessionService) {
        this.router = router;
        this.sessionService = sessionService;
    }
    /**
     * @return {?}
     */
    canActivate() {
        if (this.sessionService.isLoggedIn) {
            return true;
        }
        else {
            this.router.navigate(['/login']);
            return false;
        }
    }
}
AuthGuard.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthGuard.ctorParameters = () => [
    { type: Router },
    { type: SessionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslationService {
    /**
     * @param {?} eventBroadcaster
     * @param {?} http
     * @param {?} _productPath
     * @param {?} useTranslationServer
     * @param {?} _translationUrl
     */
    constructor(eventBroadcaster, http, _productPath, useTranslationServer, _translationUrl) {
        this.eventBroadcaster = eventBroadcaster;
        this.http = http;
        this._productPath = _productPath;
        this.useTranslationServer = useTranslationServer;
        this._translationUrl = _translationUrl;
        this._useTranslationServer = false;
        this.productPath = '';
        this._localeData = new Subject();
        this.productPath = _productPath || '/';
        this._useTranslationServer = useTranslationServer || false;
        if (this._translationUrl === null) {
            this._translationUrl = '/translate/translate';
        }
        if (this.isRunningOnBrowser()) {
            /** @type {?} */
            const comingFromReact = ((/** @type {?} */ (global))).sessionStorage.getItem('language') || 'en_US';
            /** @type {?} */
            let langLocalStorage = ((/** @type {?} */ (global))).localStorage.getItem('language');
            if (comingFromReact.indexOf('es') !== -1 && !this._useTranslationServer) {
                langLocalStorage = 'es';
                ((/** @type {?} */ (global))).localStorage.setItem('language', 'es');
            }
            else if (comingFromReact.indexOf('en') !== -1 &&
                !this._useTranslationServer) {
                langLocalStorage = 'en';
                ((/** @type {?} */ (global))).localStorage.setItem('language', 'en');
            }
            else {
                langLocalStorage = comingFromReact;
                ((/** @type {?} */ (global))).localStorage.setItem('language', langLocalStorage);
            }
            /** @type {?} */
            let localLang;
            if (this._useTranslationServer) {
                this.lang(langLocalStorage ? langLocalStorage : 'en_US');
                localLang = langLocalStorage ? langLocalStorage : 'en_US';
            }
            else {
                this.lang(langLocalStorage ? langLocalStorage : 'en');
                localLang = langLocalStorage ? langLocalStorage : 'en';
            }
            // add this next line to correct react projects
            if (localLang === 'en') {
                localLang = localLang + '_US';
            }
            else if (localLang === 'es') {
                localLang = localLang + '_MX';
            }
            ((/** @type {?} */ (global))).sessionStorage.setItem('language', localLang);
        }
        else {
            if (this._useTranslationServer) {
                this.lang('en_US');
            }
            else {
                this.lang('en');
            }
        }
    }
    /**
     * st comes from static-translation
     * @param {?} textID
     * @return {?}
     */
    static st(textID) {
        /** @type {?} */
        const textValue = this.translation.get(textID);
        if (!textValue || textValue === undefined) {
            return 'NOT:' + textID;
        }
        return textValue;
    }
    /**
     * gets all translations
     * @return {?}
     */
    static all() {
        /** @type {?} */
        const result = this.translation;
        return result;
    }
    /**
     * @return {?}
     */
    get localeData() {
        return this._localeData.asObservable();
    }
    /**
     * @return {?}
     */
    isRunningOnBrowser() {
        return ((/** @type {?} */ (global))) !== null && ((/** @type {?} */ (global))) !== undefined;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        this.labels = value;
        this._localeData.next(value);
    }
    /**
     * this method is left here for backwards compatibility
     * @param {?} lang
     * @return {?}
     */
    lang(lang) {
        if (lang === TranslationService.language) {
            return;
        }
        TranslationService.language = lang;
        // add this next line to correct react projects, need to correct this
        /** @type {?} */
        let localLang = TranslationService.language;
        if (localLang === 'en') {
            localLang = localLang + '_US';
        }
        else if (localLang === 'es') {
            localLang = localLang + '_MX';
        }
        if (this.isRunningOnBrowser()) {
            sessionStorage.setItem('language', localLang);
        }
        // if the language is only 2 letters it might be a legacy application
        if (!this._useTranslationServer) {
            this.http
                .get(this.productPath + 'vendor/locale-' + lang + '.json')
                .toPromise()
                .then((/**
             * @param {?} response
             * @return {?}
             */
            response => this.populateTranslation(response.json())))
                .catch(this.handleError);
        }
        else {
            // if the translation name is bigger than 2 letters, request to external server
            this.http
                .get(this._translationUrl + this.productPath + localLang)
                .toPromise()
                .then((/**
             * @param {?} response
             * @return {?}
             */
            response => this.populateTranslation(response.json())))
                .catch(this.handleError);
        }
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    isoLang(lang) {
        // must contain either one of these symbols
        if (lang.indexOf('-') !== -1 || lang.indexOf('_') !== -1) {
            TranslationService.language = lang;
            ((/** @type {?} */ (global))).sessionStorage.setItem('language', lang);
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    file(url) {
        this.http
            .get(url)
            .toPromise()
            .then((/**
         * @param {?} response
         * @return {?}
         */
        response => this.populateTranslation(response.json())))
            .catch(this.handleError);
    }
    /**
     * pt comes from public-translation
     * @param {?} textID
     * @return {?}
     */
    pt(textID) {
        /** @type {?} */
        const textValue = TranslationService.translation.get(textID);
        if (!textValue || textValue === undefined) {
            return 'NOT:' + textID;
        }
        return textValue;
    }
    /**
     * @param {?} textId
     * @return {?}
     */
    getLabel(textId) {
        /** @type {?} */
        const textValue = TranslationService.translation.get(textId);
        if (!textValue) {
            return undefined;
        }
        return textValue;
    }
    /**
     * @return {?}
     */
    getlang() {
        return TranslationService.language;
    }
    /**
     * @return {?}
     */
    getCountryCode() {
        return TranslationService.language.split('_')[1];
    }
    /**
     * @param {?} result
     * @return {?}
     */
    populateTranslation(result) {
        for (const item of Object.keys(result)) {
            TranslationService.translation.set(item, result[item]);
        }
        this.eventBroadcaster.broadcast(Broadcaster.DCM_LANGUAGE_FETCHED, TranslationService.language);
        this.onChange(result);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Promise.reject(error.message || error);
    }
}
TranslationService.translation = new Map();
TranslationService.language = '';
// Must be set on path constants
TranslationService.PRODUCT_PATH = 'PRODUCT_PATH';
TranslationService.USE_TRANSLATION_SERVER = 'USE_TRANSLATION_SERVER';
TranslationService.TRANSLATION_BASE_URL = 'TRANSLATION_BASE_URL';
TranslationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslationService.ctorParameters = () => [
    { type: Broadcaster },
    { type: Http },
    { type: String, decorators: [{ type: Inject, args: [TranslationService.PRODUCT_PATH,] }, { type: Optional }] },
    { type: Boolean, decorators: [{ type: Inject, args: [TranslationService.USE_TRANSLATION_SERVER,] }, { type: Optional }] },
    { type: String, decorators: [{ type: Inject, args: [TranslationService.TRANSLATION_BASE_URL,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Logger {
    /**
     * @param {?} value
     * @return {?}
     */
    static log(value) {
        console.log(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static error(value) {
        console.error(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static warn(value) {
        console.warn(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static logf(value) {
        console.log(value);
    }
}
Logger.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeatureToggleService {
    /**
     * @param {?} eventBroadcaster
     * @param {?} http
     * @param {?} _productPath
     * @param {?} _productEnvironment
     * @param {?} localManifest
     */
    constructor(eventBroadcaster, http, _productPath, _productEnvironment, localManifest) {
        this.eventBroadcaster = eventBroadcaster;
        this.http = http;
        this._productPath = _productPath;
        this._productEnvironment = _productEnvironment;
        this.localManifest = localManifest;
        this.productPath = '';
        this.productEnvironment = '';
        this.productPath = _productPath || '/';
        this.productEnvironment = _productEnvironment || 'development';
        this.getFeatureList(this.localManifest || false);
    }
    /**
     * gets all features
     * @return {?}
     */
    static all() {
        /** @type {?} */
        const result = this.featureList;
        return result;
    }
    /**
     * this method returns either true or false if the list of the features
     * requested is enabled in this environment and for this user
     * @param {?} featureId
     * @param {?=} releaseVersion
     * @param {?=} featureVersion
     * @param {?=} hostName
     * @return {?}
     */
    feature(featureId, releaseVersion, featureVersion, hostName) {
        if (typeof featureId === 'string') {
            return this.coreValidator(featureId, releaseVersion, featureVersion, hostName);
        }
        else {
            featureId.forEach((/**
             * @param {?} singleFeature
             * @return {?}
             */
            singleFeature => {
                if (!this.coreValidator(singleFeature, releaseVersion, featureVersion, hostName)) {
                    return false;
                }
            }));
        }
        return true;
    }
    /**
     * this method returns all list of features
     * @return {?}
     */
    getAll() {
        return FeatureToggleService.featureList;
    }
    /**
     * this method allows to load the feature list from the file
     * @param {?} loadFromLocalList
     * @return {?}
     */
    getFeatureList(loadFromLocalList) {
        // if the loadfromlocallist is true, then load the local-feature.json file
        if (loadFromLocalList) {
            this.http
                .get(this.productPath + 'vendor/local-feature.json')
                .toPromise()
                .then((/**
             * @param {?} response
             * @return {?}
             */
            response => this.populateFeatures(response.json())))
                .catch(this.handleError);
        }
        else {
            // if the API is ready then switch is this one
            this.http
                .get('/feature/api' + this.productPath)
                .toPromise()
                .then((/**
             * @param {?} response
             * @return {?}
             */
            response => this.populateFeatures(response.json())))
                .catch(this.handleError);
        }
    }
    /**
     * @param {?} featureId
     * @param {?=} releaseVersion
     * @param {?=} featureVersion
     * @param {?=} hostName
     * @return {?}
     */
    coreValidator(featureId, releaseVersion, featureVersion, hostName) {
        // todo smaller refactor
        /** @type {?} */
        const localFind = FeatureToggleService.featureList.get(featureId);
        if (localFind === undefined) {
            return false;
        }
        // if it is found then verify against the country
        if (localFind.country !== null && localFind.country !== undefined) {
            // we can take the country from the session storage
            if (window.sessionStorage.getItem('country').indexOf(localFind.country) ===
                -1) {
                return false;
            }
        }
        if (localFind.role !== null && localFind.role !== undefined) {
            /** @type {?} */
            let isRoleAssigned = false;
            /** @type {?} */
            const appsAvailable = JSON.parse(window.sessionStorage.getItem('applications'));
            appsAvailable.forEach((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                app.roles.forEach((/**
                 * @param {?} role
                 * @return {?}
                 */
                role => {
                    if (((/** @type {?} */ (role))).roleCode === localFind.role) {
                        isRoleAssigned = true;
                    }
                }));
            }));
            if (!isRoleAssigned) {
                return false;
            }
        }
        if (localFind.role_match !== null && localFind.role_match !== undefined) {
            /** @type {?} */
            let rolesAssigned = 0;
            /** @type {?} */
            const appsAvailable = JSON.parse(window.sessionStorage.getItem('applications'));
            appsAvailable.forEach((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                app.roles.forEach((/**
                 * @param {?} role
                 * @return {?}
                 */
                role => {
                    if (localFind.role_match.indexOf(((/** @type {?} */ (role))).roleCode) !== -1) {
                        rolesAssigned = rolesAssigned + 1;
                    }
                }));
            }));
            if (rolesAssigned !== localFind.role_match.split(',').length) {
                return false;
            }
        }
        if (localFind.role_any !== null && localFind.role_any !== undefined) {
            /** @type {?} */
            let rolesAssigned = 0;
            /** @type {?} */
            const appsAvailable = JSON.parse(window.sessionStorage.getItem('applications'));
            appsAvailable.forEach((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                app.roles.forEach((/**
                 * @param {?} role
                 * @return {?}
                 */
                role => {
                    if (localFind.role_any.indexOf(((/** @type {?} */ (role))).roleCode) !== -1) {
                        rolesAssigned = rolesAssigned + 1;
                    }
                }));
            }));
            if (rolesAssigned === 0) {
                return false;
            }
        }
        if (localFind.environment !== null && localFind.environment !== undefined) {
            // verify the injection of the environment
            if (localFind.environment !== this.productEnvironment) {
                return false;
            }
        }
        if (localFind.release_version !== null &&
            localFind.release_version !== undefined) {
            // verify the injection of the environment
            if (localFind.release_version !== releaseVersion) {
                return false;
            }
        }
        if (localFind.feature_version !== null &&
            localFind.feature_version !== undefined) {
            // verify the injection of the environment
            if (localFind.feature_version !== featureVersion) {
                return false;
            }
        }
        if (localFind.host_name !== null && localFind.host_name !== undefined) {
            // verify the injection of the environment
            if (localFind.host_name !== hostName) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return Promise.reject(error.message || error);
    }
    /**
     * @param {?} result
     * @return {?}
     */
    populateFeatures(result) {
        for (const item of Object.keys(result)) {
            FeatureToggleService.featureList.set(((/** @type {?} */ (result[item]))).feature, result[item]);
        }
        // this.eventBroadcaster.broadcast(Broadcaster.DCM_LANGUAGE_FETCHED, TranslationService.language);
        // this.onChange(result);
    }
}
FeatureToggleService.featureList = new Map();
FeatureToggleService.language = '';
// Must be set on path constants
FeatureToggleService.PRODUCT_PATH = 'PRODUCT_PATH';
FeatureToggleService.ENVIRONMENT = 'PRODUCT_PATH';
FeatureToggleService.USE_LOCAL_MANIFEST = 'USE_LOCAL_MANIFEST';
FeatureToggleService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FeatureToggleService.ctorParameters = () => [
    { type: Broadcaster },
    { type: Http },
    { type: String, decorators: [{ type: Inject, args: [FeatureToggleService.PRODUCT_PATH,] }, { type: Optional }] },
    { type: String, decorators: [{ type: Inject, args: [FeatureToggleService.ENVIRONMENT,] }, { type: Optional }] },
    { type: Boolean, decorators: [{ type: Inject, args: [FeatureToggleService.USE_LOCAL_MANIFEST,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountryConfigService {
    /**
     * @param {?} http
     * @param {?} projectEnv
     * @param {?} sessionService
     */
    constructor(http, projectEnv, sessionService) {
        this.http = http;
        this.projectEnv = projectEnv;
        this.sessionService = sessionService;
        this._countryConfig = new BehaviorSubject(null);
        this._countryConfigApiPath = '/v5/secm/console/countryconfig';
        if (!this._countryConfig.getValue()) {
            this.getCountryConfiguration().subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                this._countryConfig.next(data);
            }));
        }
    }
    /**
     * @return {?}
     */
    get countryConfig() {
        return this._countryConfig.asObservable();
    }
    /**
     * @return {?}
     */
    getCountryConfiguration() {
        /** @type {?} */
        const userCountry = this.sessionService.userCountry || 'US';
        /** @type {?} */
        const url = `${this.projectEnv.getBaseOrgEnvPath()}${this._countryConfigApiPath}?countryCode=${userCountry}`;
        return this.http.get(url).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => res.json())), catchError(this.handleError));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // In a real world app, we might use a remote logging infrastructure
        /** @type {?} */
        let errMsg;
        if (error instanceof Response) {
            /** @type {?} */
            const body = error.json() || '';
            /** @type {?} */
            const err = body.error || JSON.stringify(body);
            errMsg = `${error.status} - ${error.statusText || ''}`;
        }
        else {
            errMsg = error.message ? error.message : error.toString();
        }
        console.error(error);
        return Observable.throw(error);
    }
}
CountryConfigService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CountryConfigService.ctorParameters = () => [
    { type: HttpCemex },
    { type: ProjectSettings },
    { type: SessionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmailValidators {
    /**
     * @param {?} c
     * @return {?}
     */
    static pattern(c) {
        /** @type {?} */
        const regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (regex.test(c.value)) {
            return null;
        }
        else {
            return {
                patternInvalid: true
            };
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NumberValidators {
    /**
     * @param {?} c
     * @return {?}
     */
    static isNumeric(c) {
        if (!isNaN(parseFloat(c.value)) && isFinite(c.value)) {
            return null;
        }
        else {
            return {
                notNumeric: true
            };
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    static onlyTwoDecimals(c) {
        /** @type {?} */
        const regexp = /^\d+(\.\d{1,2})?$/;
        if (regexp.test(c.value)) {
            return null;
        }
        else {
            return {
                patternInvalid: true
            };
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    static greaterThanZero(c) {
        if (parseFloat(c.value) > 0) {
            return null;
        }
        else {
            return {
                lessThanZero: true
            };
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    static isPositive(c) {
        if (parseFloat(c.value) >= 0) {
            return null;
        }
        else {
            return {
                isNegative: true
            };
        }
    }
    /**
     * @param {?} max
     * @return {?}
     */
    static lessThan(max) {
        /** @type {?} */
        const maxNumber = max;
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            const num = +control.value;
            if (isNaN(num) || num > maxNumber) {
                return {
                    isGreater: true
                };
            }
            return null;
        });
    }
    /**
     * @param {?} min
     * @return {?}
     */
    static greaterThan(min) {
        /** @type {?} */
        const minNumber = min;
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            const num = +control.value;
            if (isNaN(num) || num < minNumber) {
                return {
                    isLess: true
                };
            }
            return null;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CashSalesService {
    /**
     * @param {?} http
     * @param {?} endpoints
     */
    constructor(http, endpoints) {
        this.http = http;
        this.endpoints = endpoints;
        // TODO: MOVE TO PATH CONSTANTS
        this.apiCashDocuments = 'cashdocuments';
    }
    /**
     * @param {?} companyCode
     * @param {?} customerCode
     * @param {?} jobSiteCode
     * @return {?}
     */
    getCreditDocs(companyCode, customerCode, jobSiteCode) {
        /** @type {?} */
        const apiQuery = `companyCode=${companyCode}&customerCode=${customerCode}&jobSiteCode=${jobSiteCode}`;
        /** @type {?} */
        const endpoint = `${this.apiCashDocuments}?${apiQuery}`;
        return this.http
            .get(this.getUrl(endpoint))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            const aux = response.json();
            return this.handleCashDocumentsData(aux);
        })))
            .toPromise()
            .then((/**
         * @param {?} data
         * @return {?}
         */
        data => data))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        error => error));
    }
    /**
     * @private
     * @param {?} aux
     * @return {?}
     */
    handleCashDocumentsData(aux) {
        aux.forEach((/**
         * @param {?} document
         * @param {?} i
         * @return {?}
         */
        (document, i) => {
            document.index = i;
            document.flagInvalidAmnt = false;
            document.errMsg = '';
            document.toCommit = 0;
            // document.createDate = '2017-01-01T00:00:00';
            if (document.createDate) {
                /** @type {?} */
                const d1 = document.createDate.split('T')[0].split('-');
                /** @type {?} */
                const d2 = document.createDate.split('T')[1];
                document.createDate = d1[2] + '-' + d1[1] + '-' + d1[0] + 'T' + d2;
                // document.createDate = this.getDateObject(document.createDate).toString();
            }
            document.amount = !document.amount ? 0 : document.amount;
            document.reconciledAmount = !document.reconciledAmount
                ? 0
                : document.reconciledAmount;
            document.commitedAmount = !document.commitedAmount
                ? 0
                : document.commitedAmount;
        }));
        return aux;
    }
    /**
     * @private
     * @param {?} api
     * @return {?}
     */
    getUrl(api) {
        /** @type {?} */
        const url = this.http.generateEndpoint(this.endpoints.V1 + this.endpoints.peCapability + api);
        return url;
    }
}
CashSalesService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CashSalesService.ctorParameters = () => [
    { type: HttpCemex },
    { type: EndpointsConstants }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountlyService {
    constructor() {
        this.defaultTrackings = [
            ['track_pageview'],
            ['track_clicks'],
            ['track_errors'],
            ['track_links'],
            ['track_forms'],
            ['collect_from_forms'] /*['track_sessions'] */
        ];
        this.Countly = ((/** @type {?} */ (window))).Countly;
    }
    /**
     * @return {?}
     */
    init() {
        this.addTracking('track_sessions');
        this.Countly.init();
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    debug(flag) {
        this.Countly.debug = flag;
    }
    /**
     * @param {?} url
     * @param {?} appKey
     * @return {?}
     */
    startService(url, appKey) {
        if (this.Countly !== undefined) {
            this.Countly.url = url;
            this.Countly.app_key = appKey;
            this.Countly.q = this.defaultTrackings;
        }
    }
    /**
     * @param {?} key
     * @param {?=} value
     * @return {?}
     */
    addTracking(key, value) {
        if (!value) {
            this.Countly.q.push([key]);
        }
        else {
            this.Countly.q.push([key, value]);
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    addTrackingPage(key) {
        this.Countly.q.push(['track_pageview', key]);
    }
    /**
     * @param {?} countryCode
     * @param {?} newId
     * @return {?}
     */
    changeId(countryCode, newId) {
        this.Countly.q.push(['change_id', countryCode + newId]);
    }
    /**
     * @param {?} userfields
     * @return {?}
     */
    identifyUser(userfields) {
        this.Countly.q.push(['user_details', userfields]);
    }
    /**
     * @return {?}
     */
    endSession() {
        this.Countly.q.push(['end_session']);
    }
    /**
     * @param {?} trackingjson
     * @return {?}
     */
    removeTracking(trackingjson) {
        this.Countly.q.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            if (element.indexOf(trackingjson) !== -1) {
                element[0] = 'canceled';
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnalyticsFactory {
    /**
     * @param {?} analitycServiceType
     * @param {?} configuration
     * @return {?}
     */
    createService(analitycServiceType, configuration) {
        switch (analitycServiceType) {
            case AnalyticsFactory.Type.Countly:
                /** @type {?} */
                const service = new CountlyService();
                service.startService(configuration.url, configuration.key);
                return service;
            case AnalyticsFactory.Type.Clevertap:
                return null;
            case AnalyticsFactory.Type.Other:
                return null;
            default:
                return null;
        }
    }
}
// tslint:disable-next-line:variable-name
AnalyticsFactory.Type = { Countly: 1, Clevertap: 2, Other: 0 };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PushNotificationsConstants {
    constructor() {
        // tslint:disable-next-line:no-string-literal
        this.appCode = window['APP_CODE']; // 'Foreman_App'
        // tslint:disable-next-line:no-string-literal
        this.apiClientId = window['CLIENT_ID']; // 'f624df7f-9b35-41c0-8a41-4854b86c84f1';
        // tslint:disable-next-line:no-string-literal
        this.apiHost = window['API_HOST']; // 'https://uscldcnxapmd01.azure-api.net/';
        // tslint:disable-next-line:no-string-literal
        this.appLanguage = window['LANGUAGE']; // 'es-MX';
        this.authToken = 'Bearer ' + sessionStorage.getItem('auth_token');
        this.jwt = sessionStorage.getItem('jwt');
        this.urlServiceWorker = 'service-worker/push_sw.js';
        this.deviceApi = this.apiHost + 'v5/cm/notifications/devices';
        this.sourcePush = 'postMessageSW';
        this.vapidPublicKey = '';
    }
    /**
     * @return {?}
     */
    getAppCode() {
        return this.appCode;
    }
    /**
     * @return {?}
     */
    getClientId() {
        return this.apiClientId;
    }
    /**
     * @return {?}
     */
    getApiBasePath() {
        return this.apiBasePath;
    }
    /**
     * @return {?}
     */
    getAppLanguage() {
        return this.appLanguage;
    }
    /**
     * @return {?}
     */
    getAuthToken() {
        return this.authToken;
    }
    /**
     * @return {?}
     */
    getJwt() {
        return this.jwt;
    }
    /**
     * @return {?}
     */
    getUrlSW() {
        return this.urlServiceWorker;
    }
    /**
     * @return {?}
     */
    getDevicesPath() {
        return this.deviceApi;
    }
    /**
     * @return {?}
     */
    getSourcePush() {
        return this.sourcePush;
    }
    /**
     * @return {?}
     */
    getVapidPublicKey() {
        return this.vapidPublicKey;
    }
    /**
     * @param {?} pVapidPublicKey
     * @return {?}
     */
    setVapidPublicKey(pVapidPublicKey) {
        this.vapidPublicKey = pVapidPublicKey;
    }
    /**
     * @param {?} urlSW
     * @return {?}
     */
    setUrlSW(urlSW) {
        this.urlServiceWorker = urlSW;
    }
}
PushNotificationsConstants.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PushNotificationsConstants.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PushNotificationService {
    /**
     * @param {?} constants
     */
    constructor(constants) {
        this.constants = constants;
        this._devUUID = '';
        this._devId = '';
        this._platform = '';
        this._token = '';
        // this.initialize();
    }
    /**
     * @param {?} methodCallBack
     * @return {?}
     */
    initialize(methodCallBack) {
        this._methodCallBack = methodCallBack;
        this._vapidPublicKey = this.constants.getVapidPublicKey();
        if (this.validateSw()) {
            // tslint:disable-next-line:only-arrow-functions
            /** @type {?} */
            const swReg = this.registerSw().catch((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                console.log('Push Service Worker registration has failed: ' + error);
            }));
            // tslint:disable-next-line:only-arrow-functions
            this.subscriptionSw(swReg).catch((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                console.log('Push Service Worker subscription has failed: ' + error);
            }));
        }
    }
    /**
     * @return {?}
     */
    validateSw() {
        /** @type {?} */
        let isValid = false;
        if ('serviceWorker' in navigator && 'PushManager' in window) {
            isValid = true;
            console.log('Service Workers is supported');
        }
        return isValid;
    }
    /**
     * @private
     * @return {?}
     */
    registerSw() {
        // tslint:disable-next-line:only-arrow-functions
        return navigator.serviceWorker
            .register(this.constants.getUrlSW())
            .then((/**
         * @param {?} swReg
         * @return {?}
         */
        function (swReg) {
            if (swReg.installing) {
                console.log('Service worker installing');
            }
            else if (swReg.waiting) {
                console.log('Service worker installed');
            }
            else if (swReg.active) {
                console.log('Service worker active');
            }
            if (!swReg.showNotification) {
                console.log('Notifications aren\'t supported on service workers.');
            }
            return swReg;
        }));
    }
    /**
     * @private
     * @param {?} registration
     * @return {?}
     */
    subscriptionSw(registration) {
        /** @type {?} */
        const mSetSubscription = this.setSubscription;
        /** @type {?} */
        const global = this;
        // tslint:disable-next-line:only-arrow-functions
        return registration.then((/**
         * @param {?} swReg
         * @return {?}
         */
        function (swReg) {
            swReg.pushManager
                .getSubscription()
                // tslint:disable-next-line:only-arrow-functions
                .then((/**
             * @param {?} subscriptionInit
             * @return {?}
             */
            function (subscriptionInit) {
                if (subscriptionInit) {
                    return mSetSubscription(subscriptionInit, global);
                }
                else {
                    /** @type {?} */
                    const options = {
                        // tslint:disable-next-line:max-line-length
                        applicationServerKey: !global._vapidPublicKey
                            ? null
                            : global.urlB64ToUint8Array(global._vapidPublicKey),
                        userVisibleOnly: true
                    };
                    return (swReg.pushManager
                        .subscribe(options)
                        // tslint:disable-next-line:only-arrow-functions
                        .then((/**
                     * @param {?} subscription
                     * @return {?}
                     */
                    function (subscription) {
                        console.log(subscription);
                        return mSetSubscription(subscription, global);
                        // tslint:disable-next-line:only-arrow-functions
                    }))
                        .catch((/**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        console.log('Unable to subscribe to push.', error);
                    })));
                }
            }));
        }));
    }
    /**
     * @private
     * @param {?} subscription
     * @param {?} global
     * @return {?}
     */
    setSubscription(subscription, global) {
        global.generateTokenForRegisterDevice(subscription);
        global.registerBroadcastListener();
    }
    /**
     * @private
     * @return {?}
     */
    registerBroadcastListener() {
        /** @type {?} */
        const callBack = this._methodCallBack;
        /** @type {?} */
        const sPush = this.constants.getSourcePush();
        navigator.serviceWorker.addEventListener('message', (/**
         * @param {?} event
         * @return {?}
         */
        function handler(event) {
            /** @type {?} */
            const data = event.data;
            if (data && data.source === sPush) {
                console.log(event.data);
                if (callBack) {
                    callBack(data.payload);
                }
            }
        }));
    }
    // tslint:disable-next-line:member-ordering
    /**
     * @param {?} subscription
     * @return {?}
     */
    generateTokenForRegisterDevice(subscription) {
        localStorage.setItem('token', JSON.stringify(subscription));
        if (!localStorage.getItem('deviceUUID')) {
            this.generateUUID('');
        }
        else {
            this._devUUID = localStorage.getItem('deviceUUID');
            if (!localStorage.getItem('deviceId')) {
                this._devId = localStorage.getItem('deviceId');
            }
        }
        this._platform = '';
        this._devUUID = localStorage.getItem('deviceUUID');
        this._devId = localStorage.getItem('deviceId');
        /** @type {?} */
        const rawKey = subscription.getKey ? subscription.getKey('p256dh') : '';
        /** @type {?} */
        const key = rawKey
            ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey)))
            : '';
        /** @type {?} */
        const rawAuthSecret = subscription.getKey
            ? subscription.getKey('auth')
            : '';
        /** @type {?} */
        const authSecret = rawAuthSecret
            ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret)))
            : '';
        /** @type {?} */
        const tokenValue = {
            endpoint: subscription.endpoint,
            userAuth: authSecret,
            userPublicKey: key
        };
        this._token = JSON.stringify(tokenValue);
        if (navigator.userAgent.indexOf('Firefox') !== -1) {
            this._platform = 'F'; // Firefox Browser
        }
        else if (navigator.userAgent.indexOf('Chrome') !== -1) {
            this._platform = 'C'; // Chrome Browser
        }
        /** @type {?} */
        let device = null;
        if (this.validateInput(this._devId)) {
            device = {
                deviceId: this._devId,
                platform: this._platform,
                token: this._token,
                uuid: this._devUUID
            };
        }
        else {
            device = {
                platform: this._platform,
                token: this._token,
                uuid: this._devUUID
            };
        }
        this.registerDevice(device);
    }
    // tslint:disable-next-line:member-ordering
    /**
     * @param {?} device
     * @return {?}
     */
    registerDevice(device) {
        console.log('Device details:', device);
        /** @type {?} */
        const xhr = this.setRequest(this.constants.getDevicesPath(), 'POST', true);
        /*this.http.post(this.constants.getDevicesPath(), device)
            .then((response) => {
                console.log('Response register,', response);
                localStorage.setItem('deviceId', response);
            });*/
        // tslint:disable-next-line:only-arrow-functions
        xhr.onreadystatechange = (/**
         * @return {?}
         */
        function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log('Response register,', xhr);
                localStorage.setItem('deviceId', xhr.responseText);
            }
        });
        xhr.send(JSON.stringify(device));
    }
    // tslint:disable-next-line:member-ordering
    /**
     * @return {?}
     */
    unRegisterDevice() {
        /** @type {?} */
        const promise = new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this._devId = localStorage.getItem('deviceId');
            /** @type {?} */
            const global = this;
            // tslint:disable-next-line:only-arrow-functions
            navigator.serviceWorker.ready
                .then((/**
             * @param {?} registration
             * @return {?}
             */
            function (registration) {
                registration
                    .unregister()
                    // tslint:disable-next-line:only-arrow-functions
                    .then((/**
                 * @param {?} checkUnregister
                 * @return {?}
                 */
                function (checkUnregister) {
                    if (!checkUnregister) {
                        console.log('unregister failed');
                        resolve();
                    }
                    global
                        .unsubscribeDevice(global._devId, global)
                        // tslint:disable-next-line:only-arrow-functions
                        .then((/**
                     * @return {?}
                     */
                    function () {
                        resolve();
                    }));
                }));
            }))
                // tslint:disable-next-line:only-arrow-functions
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                console.log('Registration failed with ' + error);
                resolve();
            }));
        }));
        return promise;
    }
    // tslint:disable-next-line:member-ordering
    /**
     * @param {?} deviceID
     * @param {?} global
     * @return {?}
     */
    unsubscribeDevice(deviceID, global) {
        /** @type {?} */
        const promise = new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const deviceId = localStorage.getItem('deviceId');
            /** @type {?} */
            const device = {
                devices: {
                    deviceId: global._devId,
                    platform: global._platform,
                    token: global._token,
                    uuid: global._devUUID
                }
            };
            if (deviceID) {
                /** @type {?} */
                const xhr = global.setRequest(global.constants.getDevicesPath() + '/' + deviceID, 'DELETE', true);
                // tslint:disable-next-line:only-arrow-functions
                xhr.onreadystatechange = (/**
                 * @return {?}
                 */
                function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        console.log('The response is ,', xhr);
                        console.log('Successfully unregistered the device');
                        localStorage.setItem('deviceUUID', '');
                        localStorage.setItem('deviceId', '');
                        localStorage.setItem('token', '');
                        resolve();
                    }
                });
                xhr.send(JSON.stringify(device));
            }
            else {
                resolve();
            }
        }));
        return promise;
    }
    /**
     * @private
     * @param {?} url
     * @param {?} method
     * @param {?} asyncP
     * @return {?}
     */
    setRequest(url, method, asyncP) {
        /** @type {?} */
        let xhr = new XMLHttpRequest();
        xhr.open(method, url, asyncP);
        xhr = this.setHeaders(xhr, method);
        return xhr;
    }
    /**
     * @private
     * @param {?} xhr
     * @param {?} method
     * @return {?}
     */
    setHeaders(xhr, method) {
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.setRequestHeader('x-ibm-client-id', this.constants.getClientId());
        xhr.setRequestHeader('App-Code', this.constants.getAppCode());
        xhr.setRequestHeader('Accept-Language', this.constants.getAppLanguage());
        xhr.setRequestHeader('Authorization', this.constants.getAuthToken());
        xhr.setRequestHeader('jwt', this.constants.getJwt());
        xhr.timeout = 3000;
        if (method === 'POST' || method === 'PUT') {
            xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        }
        return xhr;
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    generateUUID(token) {
        /** @type {?} */
        let dateTime = new Date().getTime();
        if (window.performance && typeof window.performance.now === 'function') {
            dateTime += performance.now(); // use high-precision timer if available
        }
        /** @type {?} */
        const hostname = window.location.hostname;
        /** @type {?} */
        const arrayData = [];
        arrayData.push(this.hashCode(dateTime));
        arrayData.push(this.hashCode(token));
        arrayData.push(this.hashCode(hostname));
        arrayData.push(this.hashCode(this._platform));
        /** @type {?} */
        const finalString = arrayData
            .join('')
            .replace(/[-.]/g, '')
            .replace(/[,.]/g, '');
        /** @type {?} */
        let uuid = '';
        for (let i = 0; i < 32; i++) {
            uuid += finalString.charAt(Math.floor(Math.random() * finalString.length));
        }
        localStorage.setItem('deviceUUID', uuid);
        this._devUUID = uuid;
        return this._devUUID;
    }
    /**
     * @private
     * @param {?} str
     * @return {?}
     */
    hashCode(str) {
        /** @type {?} */
        let hash = 0;
        /** @type {?} */
        let i;
        /** @type {?} */
        let chr;
        /** @type {?} */
        let len;
        if (str.length === 0) {
            return hash;
        }
        for (i = 0, len = str.length; i < len; i++) {
            chr = str.charCodeAt(i);
            // tslint:disable-next-line:no-bitwise
            hash = (hash << 5) - hash + chr;
            // tslint:disable-next-line:no-bitwise
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }
    /**
     * @private
     * @param {?} stringValue
     * @return {?}
     */
    validateInput(stringValue) {
        // tslint:disable-next-line:max-line-length
        return stringValue === undefined ||
            stringValue == null ||
            stringValue.length <= 0 ||
            stringValue === ''
            ? false
            : true;
    }
    /**
     * @private
     * @param {?} base64String
     * @return {?}
     */
    urlB64ToUint8Array(base64String) {
        /** @type {?} */
        const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
        /** @type {?} */
        const base64 = (base64String + padding)
            .replace(/\-/g, '+')
            .replace(/_/g, '/');
        /** @type {?} */
        const rawData = window.atob(base64);
        /** @type {?} */
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }
}
PushNotificationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PushNotificationService.ctorParameters = () => [
    { type: PushNotificationsConstants }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CORE_COMMON_PROVIDERS = [
    ProjectSettings,
    HttpCemex,
    SessionService,
    Broadcaster,
    AuthGuard,
    TranslationService
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxCoreCommonModule {
}
CmxCoreCommonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                exports: [],
                imports: [],
                providers: [CORE_COMMON_PROVIDERS]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CORE_COMMON_PROVIDERS, CmxCoreCommonModule, HttpCemex, SessionService, LegalEntity, FinancialDocuments, ProjectSettings, AuthGuard, TranslationService, Logger, FeatureToggleService, CountryConfigService, EmailValidators, NumberValidators, CashSalesService, AnalyticsFactory, CountlyService, PushNotificationsConstants, PushNotificationService };

//# sourceMappingURL=cemex-core-angular-services-v7.js.map