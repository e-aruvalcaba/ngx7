import * as moment_ from 'moment';
import { HttpClient } from '@angular/common/http';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { ReplaySubject, Subject } from 'rxjs';
import { Inject, Injectable, Optional, Pipe, PLATFORM_ID, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslationService {
    // we can change 'languageLoaded' to 'selectedLanguageSubject' in translation resolver  ???
    /**
     * @param {?} httpClient
     * @param {?} productPath
     * @param {?} loadedLanguages
     * @param {?} defaultLanguageISO
     */
    constructor(httpClient, productPath, loadedLanguages, defaultLanguageISO // e.g.: en_US from america region || en_UK from europe region.
    ) {
        this.httpClient = httpClient;
        this.productPath = productPath;
        this.loadedLanguages = loadedLanguages;
        this.defaultLanguageISO = defaultLanguageISO;
        this.languageLoaded = new ReplaySubject(1);
        this.selectedLanguageSubject = new ReplaySubject(1);
        this.languagesSubject = new ReplaySubject(1);
        if (!this.loadedLanguages) {
            console.warn('The Translation Service can\'t init without Injected Languages.');
            console.warn('Inject the languages from your application: > ' +
                '{ provide: \'TRANSLATION_LANGUAGES, useValue: window[\'CMX_LANGUAGES\'] },\'');
            return;
        }
        if (!defaultLanguageISO) {
            console.warn('The Translation Service need defaultLanguageISO.');
        }
        TranslationService.languages = this.loadedLanguages;
        /** @type {?} */
        const localStorageLanguage = ((/** @type {?} */ (global))).localStorage.getItem('language');
        /** @type {?} */
        const allKeys = Object.keys(TranslationService.translations);
        if (allKeys.length === 0) {
            this.setLanguage(localStorageLanguage || defaultLanguageISO);
        }
        else {
            this.languageLoaded.next(true);
            // we can change 'languageLoaded' to 'selectedLanguageSubject' in translation resolver?
        }
    }
    /**
     * \@description Gets the labels data from the server.
     * @param {?} $lang Language code for the file
     * @return {?}
     */
    getTranslations($lang) {
        /** @type {?} */
        const endpoint = `/translate/translate/${this.productPath}/${$lang}`;
        return this.httpClient.get(endpoint);
    }
    /**
     * \@description Observable to gets the languages that exist in the server
     * @return {?}
     */
    getLanguages() {
        return this.languagesSubject.asObservable();
    }
    /**
     * @return {?}
     */
    getSelectedLanguage() {
        return this.selectedLanguageSubject.asObservable();
    }
    /**
     * \@description Retrieve the public translation of a label
     * @param {?} $textId Label id as written in the json file
     * @return {?}
     */
    pt($textId) {
        /** @type {?} */
        const textValue = TranslationService.translations[$textId];
        if (!textValue || textValue === undefined) {
            return 'NOT:' + $textId;
        }
        return textValue;
    }
    /**
     * \@description Retrieve the public translation of a label
     * @param {?} $textId Label id as written in the json file
     * @return {?}
     */
    getLabel($textId) {
        /** @type {?} */
        const textValue = TranslationService.translations[$textId];
        if (!textValue || textValue === undefined) {
            return 'NOT:' + $textId;
        }
        return textValue;
    }
    /**
     * \@description Retrieve language published on the server.
     * @param {?} $languageISO Can be the country code or the language iso combination
     * @return {?}
     */
    getLanguage($languageISO) {
        if ($languageISO !== undefined && $languageISO !== null) {
            /** @type {?} */
            let langValue;
            langValue = TranslationService.languages.find((/**
             * @param {?} language
             * @return {?}
             */
            language => {
                return (language.languageISO === $languageISO ||
                    language.countryCode.toLowerCase() === $languageISO.toLowerCase() ||
                    language.languageISO.includes($languageISO));
            }));
            // if the language cannot reached, go for default
            if (langValue === undefined) {
                console.warn('The Language cannot reached', $languageISO);
                langValue = this.getDefaultLanguage();
            }
            langValue.momentConfig = this.getMomentConfig(langValue);
            return langValue;
        }
        else {
            console.warn('$languageIso param is undefined.');
            return this.getDefaultLanguage();
        }
    }
    /**
     * \@description Retrieve language published on the server.
     * @param {?} $countryCode Can be the country code or the language iso combination
     * @return {?}
     */
    getLanguageByCountryCode($countryCode) {
        if ($countryCode !== undefined && $countryCode !== null) {
            /** @type {?} */
            let langValue;
            /** @type {?} */
            const countryLan = TranslationService.languages.filter((/**
             * @param {?} $language
             * @return {?}
             */
            $language => {
                return ($language.countryCode.toLowerCase() === $countryCode.toLowerCase());
            }));
            if (countryLan.length > 1) {
                /** @type {?} */
                const languageCode = sessionStorage.getItem('language');
                langValue = countryLan.find((/**
                 * @param {?} $language
                 * @return {?}
                 */
                $language => {
                    return ($language.languageISO.toLowerCase() === languageCode.toLowerCase());
                }));
            }
            else {
                langValue =
                    countryLan && countryLan.length > 0 ? countryLan[0] : undefined;
            }
            // if the language cannot reached, go for default
            if (langValue === undefined) {
                console.warn('The Language cannot reached', $countryCode);
                langValue = this.getDefaultLanguage();
            }
            langValue.momentConfig = this.getMomentConfig(langValue);
            return langValue;
        }
        else {
            console.warn('$countryCode param is undefined.');
            return this.getDefaultLanguage();
        }
    }
    /**
     * \@description Set language by languageISO or CountryCode.
     * @param {?} $languageISO Can be the country code or the language iso combination
     * @return {?}
     */
    setLanguage($languageISO) {
        this.selectedLanguage = this.getLanguage($languageISO);
        for (const lang of TranslationService.languages) {
            lang.isSelected = lang.languageISO === this.selectedLanguage.languageISO;
            lang.dir = lang.textFloat === 'right' ? 'rtl' : 'ltr';
            lang.rtl = lang.dir === 'rtl' ? true : false;
        }
        this.getTranslations(this.selectedLanguage.languageISO).subscribe((/**
         * @param {?} translations
         * @return {?}
         */
        translations => this.populateTranslation(translations)));
    }
    /**
     * @param {?} $result
     * @return {?}
     */
    populateTranslation($result) {
        TranslationService.translations = $result;
        // emit changes until populate is completed
        localStorage.setItem('language', this.selectedLanguage.languageISO);
        sessionStorage.setItem('language', this.selectedLanguage.languageISO);
        this.languageLoaded.next(true);
        // we can change 'languageLoaded' to 'selectedLanguageSubject' in translation resolver?
        this.selectedLanguageSubject.next(this.selectedLanguage);
        this.languagesSubject.next(TranslationService.languages);
    }
    /**
     * @return {?}
     */
    get selectedLanguage() {
        return TranslationService.currentLanguage;
    }
    /**
     * @param {?} language
     * @return {?}
     */
    set selectedLanguage(language) {
        TranslationService.currentLanguage = language;
    }
    /**
     * @return {?}
     */
    getDefaultLanguage() {
        /** @type {?} */
        let defaultLangValue;
        defaultLangValue = TranslationService.languages.find((/**
         * @param {?} language
         * @return {?}
         */
        language => {
            return (language.languageISO === this.defaultLanguageISO ||
                language.countryCode.toLowerCase() ===
                    this.defaultLanguageISO.toLowerCase() ||
                language.languageISO.includes(this.defaultLanguageISO));
        }));
        if (defaultLangValue === undefined) {
            console.warn('The Default Language cannot reached', this.defaultLanguageISO);
            defaultLangValue = TranslationService.languages[0];
            console.warn('Trying get the first language', defaultLangValue.languageISO);
        }
        else {
            console.warn('The Default Language is', defaultLangValue.languageISO);
        }
        return defaultLangValue;
    }
    /**
     * @param {?} countryCode
     * @return {?}
     */
    getLanguagesByCountryCode(countryCode) {
        /** @type {?} */
        const languagesByContryCode = TranslationService.languages.filter((/**
         * @param {?} language
         * @return {?}
         */
        language => language.countryCode.toLowerCase() === countryCode.toLowerCase()));
        return languagesByContryCode;
    }
    /**
     * @private
     * @param {?} language
     * @return {?}
     */
    getMomentConfig(language) {
        return {
            months: language.monthNames.split(','),
            monthsShort: language.shortDayMonths.split(','),
            weekdays: language.dayNames.split(','),
            weekdaysMin: language.shortDayNames2.split(','),
            weekdaysShort: language.shortDayNames.split(',')
        };
    }
}
TranslationService.TRANSLATION_PRODUCT_PATH = 'TRANSLATION_PRODUCT_PATH';
TranslationService.TRANSLATION_LANGUAGES = 'TRANSLATION_LANGUAGES';
TranslationService.DEFAULT_LANGUAGE_ISO = 'DEFAULT_LANGUAGE_ISO';
TranslationService.currentLanguage = undefined;
TranslationService.translations = {};
TranslationService.languages = [];
TranslationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslationService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Inject, args: [TranslationService.TRANSLATION_PRODUCT_PATH,] }, { type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: [TranslationService.TRANSLATION_LANGUAGES,] }, { type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: [TranslationService.DEFAULT_LANGUAGE_ISO,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * From https://github.com/shrpne/from-exponential
 * Can't install the package beacause it is ES6, UglifyJS on its version compatible with Webpack 3 can't do ES6
 * The code needs to be copied locally so Typescript could compile it to ES5
 * or just upgrade to Webpack 4 and use the webpack-uglify-plugin
 */
/**
 * Return two parts array of exponential number
 * @param {?} num - number or array of its parts
 * @return {?}
 */
function getExponentialParts(num) {
    return Array.isArray(num) ? num : String(num).split(/[eE]/);
}
/**
 *
 * @param {?} num - number or array of its parts
 * @return {?}
 */
function isExponential(num) {
    /** @type {?} */
    const eParts = getExponentialParts(num);
    return !Number.isNaN(Number(eParts[1]));
}
/**
 * Converts exponential notation to a human readable string
 * @param {?} num - number or array of its parts
 * @return {?}
 */
function fromExponential(num) {
    /** @type {?} */
    const eParts = getExponentialParts(num);
    if (!isExponential(eParts)) {
        return eParts[0];
    }
    /** @type {?} */
    const sign = eParts[0][0] === '-' ? '-' : '';
    /** @type {?} */
    const digits = eParts[0].replace(/^-/, '');
    /** @type {?} */
    const digitsParts = digits.split('.');
    /** @type {?} */
    const wholeDigits = digitsParts[0];
    /** @type {?} */
    const fractionDigits = digitsParts[1] || '';
    /** @type {?} */
    let e = Number(eParts[1]);
    if (e === 0) {
        return `${sign + wholeDigits}.${fractionDigits}`;
    }
    else if (e < 0) {
        // move dot to the left
        /** @type {?} */
        const countWholeAfterTransform = wholeDigits.length + e;
        if (countWholeAfterTransform > 0) {
            // transform whole to fraction
            /** @type {?} */
            const wholeDigitsAfterTransform = wholeDigits.substr(0, countWholeAfterTransform);
            /** @type {?} */
            const wholeDigitsTransformedToFracton = wholeDigits.substr(countWholeAfterTransform);
            return `${sign +
                wholeDigitsAfterTransform}.${wholeDigitsTransformedToFracton}${fractionDigits}`;
        }
        else {
            // not enough whole digits: prepend with fractional zeros
            // first e goes to dotted zero
            /** @type {?} */
            let zeros = '0.';
            e += 1;
            while (e) {
                zeros += '0';
                e += 1;
            }
            return sign + zeros + wholeDigits + fractionDigits;
        }
    }
    else {
        // move dot to the right
        /** @type {?} */
        const countFractionAfterTransform = fractionDigits.length - e;
        if (countFractionAfterTransform > 0) {
            // transform fraction to whole
            // countTransformedFractionToWhole = e
            /** @type {?} */
            const fractionDigitsAfterTransform = fractionDigits.substr(e);
            /** @type {?} */
            const fractionDigitsTransformedToWhole = fractionDigits.substr(0, e);
            return `${sign +
                wholeDigits +
                fractionDigitsTransformedToWhole}.${fractionDigitsAfterTransform}`;
        }
        else {
            // not enough fractions: append whole zeros
            /** @type {?} */
            let zerosCount = -countFractionAfterTransform;
            /** @type {?} */
            let zeros = '';
            while (zerosCount) {
                zeros += '0';
                zerosCount -= 1;
            }
            return sign + wholeDigits + fractionDigits + zeros;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moment = moment_;
/** @enum {number} */
const DateTimeActions = {
    ConvertToLocal: 0,
    NoConvertToLocal: 1,
};
DateTimeActions[DateTimeActions.ConvertToLocal] = 'ConvertToLocal';
DateTimeActions[DateTimeActions.NoConvertToLocal] = 'NoConvertToLocal';
class FormatterService {
    constructor() { }
    // DATES
    /**
     * \@description Transforms a valid string to a date object
     * @param {?} date The date as string
     * @return {?} A javascript date object
     */
    getDateObject(date) {
        try {
            /** @type {?} */
            const auxDate = date.replace(/-g/, '/');
            /** @type {?} */
            const bits = auxDate.split(/\D/);
            /** @type {?} */
            const month = parseInt(bits[1], undefined) - 1;
            if (bits.length === 3) {
                return new Date(bits[0], month, bits[2]);
            }
            else {
                return new Date(bits[0], month, bits[2], bits[3], bits[4], bits[5]);
            }
        }
        catch ($exception) {
            return undefined;
        }
    }
    /**
     * @param {?} date
     * @param {?} languageISO
     * @param {?} format
     * @param {?=} action
     * @return {?}
     */
    formatDateTimeMoment(date, languageISO, format, action = DateTimeActions.ConvertToLocal) {
        if (TranslationService.currentLanguage) {
            moment.updateLocale(TranslationService.currentLanguage.languageISO.substr(0, 2), TranslationService.currentLanguage.momentConfig);
        }
        if (action === DateTimeActions.NoConvertToLocal) {
            return moment(date)
                .locale(languageISO.substr(0, 2))
                .format(format);
        }
        return this.utcToLocal(date)
            .locale(languageISO.substr(0, 2))
            .format(format);
    }
    /**
     * \@description Format a number by TypeScript Number function
     * The static value '-u-nu-latn' is for always returns commons numbers '1,2,3,4,5,6,7,8,9,0'
     * @param {?} numberEntry
     * @param {?} languageISO
     * @param {?} decimalNumbers
     * @return {?} A value formatted
     */
    formatNumberTS(numberEntry, languageISO, decimalNumbers) {
        if (isNaN(numberEntry) || numberEntry === null) {
            return 0;
        }
        return Number(this.round(numberEntry, decimalNumbers).toFixed(decimalNumbers)).toLocaleString(languageISO + '-u-nu-latn', {
            minimumFractionDigits: numberEntry % 1 === 0 ? 0 : decimalNumbers
        });
    }
    /**
     * @param {?} dateEntry
     * @return {?}
     */
    utcToLocal(dateEntry) {
        return moment.utc(dateEntry).local();
    }
    /**
     * @param {?} date
     * @param {?=} format
     * @return {?}
     */
    localToUtc(date, format) {
        if (format !== undefined) {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format(format);
        }
        else {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format();
        }
    }
    // expected time '00:00:00'
    /**
     * @param {?} time
     * @return {?}
     */
    timeToMinutes(time) {
        /** @type {?} */
        const timeSplit = time.split(':');
        /** @type {?} */
        const hours = +timeSplit[0];
        /** @type {?} */
        const minutes = +timeSplit[1];
        /** @type {?} */
        const seconds = +timeSplit[2];
        return hours * 60 + minutes + this.roundToDown(seconds / 60);
    }
    // NUMBERS
    /**
     * \@description Formats a number as a currency preserving its precision.
     * In order the keep the precision the number must be passed as a string
     * @param {?} value The number value to format
     * @param {?=} numberDecimals The number of decimals to use
     * @param {?=} thousandSeparator The string character to use when separating numbers
     * @param {?=} decimalSeparator The string character to use when separating the decimal and integer part
     * @return {?} The number as a currency string
     */
    formatNumber(value, numberDecimals, thousandSeparator, decimalSeparator) {
        // tslint:disable-next-line: triple-equals
        if (value == undefined || value.toString() == '' || isNaN((/** @type {?} */ (value)))) {
            console.warn('Not a valid number to format');
            return '';
        }
        // tslint:disable-next-line:triple-equals
        numberDecimals = numberDecimals != undefined ? numberDecimals : 2;
        // tslint:disable-next-line:triple-equals
        thousandSeparator =
            thousandSeparator !== undefined ? thousandSeparator : ',';
        // tslint:disable-next-line:triple-equals
        decimalSeparator = decimalSeparator !== undefined ? decimalSeparator : '.';
        /** @type {?} */
        const completeNumber = fromExponential(value);
        /** @type {?} */
        const sign = value < 0 ? '-' : '';
        /** @type {?} */
        const absoluteValue = value < 0 ? completeNumber.split('-')[1] : completeNumber;
        /** @type {?} */
        const truncatedDecimalValue = absoluteValue.split('.')[1] &&
            absoluteValue.split('.')[1].slice(0, numberDecimals);
        /** @type {?} */
        const integerPart = absoluteValue.split('.')[0];
        /** @type {?} */
        const floatingPart = this.rightPad(truncatedDecimalValue, '0', numberDecimals);
        /** @type {?} */
        let formattedInteger = integerPart;
        if (Number(integerPart) >= 1000) {
            formattedInteger = integerPart.replace(/./g, (/**
             * @param {?} c
             * @param {?} i
             * @param {?} a
             * @return {?}
             */
            (c, i, a) => {
                return i && c !== decimalSeparator && (a.length - i) % 3 === 0
                    ? thousandSeparator + c
                    : c;
            }));
        }
        // tslint:disable-next-line:max-line-length
        /** @type {?} */
        const formattedNumber = `${sign}${formattedInteger}${floatingPart.length > 0 ? decimalSeparator : ''}${floatingPart}`;
        return formattedNumber;
    }
    /**
     * @param {?} value
     * @param {?} decimals
     * @return {?}
     */
    round(value, decimals) {
        /** @type {?} */
        let type = '';
        type = 'round';
        /** @type {?} */
        const valueDecimals = value % 1;
        if (valueDecimals !== 0.5) {
            return Number(Math[type](value + 'e' + decimals) + 'e-' + decimals);
        }
        else {
            return Number(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    roundToDown(value) {
        return Math.floor(value);
    }
    // STRINGS
    /**
     * @param {?} value
     * @return {?}
     */
    removeFirstZeros(value) {
        return value.replace(/^0+/, '');
    }
    /**
     * @param {?} text
     * @param {?} wildcard
     * @param {?} length
     * @return {?}
     */
    pad(text, wildcard, length) {
        /** @type {?} */
        let result = text;
        while (result.length < length) {
            result = wildcard + result;
        }
        return result;
    }
    /**
     * \@description Fills up a string with the specified character appending it to the right till lenght is achieved
     * @param {?} text String to add padding
     * @param {?} wildcard Character that's gonne be repeated
     * @param {?} length
     * @return {?}
     */
    rightPad(text, wildcard, length) {
        if (text === undefined || text === null || text === '') {
            return wildcard.repeat(length);
        }
        /** @type {?} */
        let str = text.toString();
        while (str.length < length) {
            str += wildcard;
        }
        return str;
    }
    /**
     * @param {?} measureUnit
     * @return {?}
     */
    formatMeasureUnit(measureUnit) {
        switch (measureUnit) {
            case 'YD3':
                return 'Yd³';
            case 'M3':
                return 'M³';
            default:
                return measureUnit;
        }
    }
}
FormatterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FormatterService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxCurrencyCustomPipe {
    /**
     * @param {?} formatter
     */
    constructor(formatter) {
        this.formatter = formatter;
        this.value = '';
    }
    /**
     * @param {?} $value
     * @param {?} $currencySymbol
     * @param {?} $decimalNumbers
     * @param {?} $thousandSeparator
     * @param {?} $decimalSeparator
     * @param {?=} $floatCurrencySymbolRight
     * @return {?}
     */
    transform($value, $currencySymbol, $decimalNumbers, $thousandSeparator, $decimalSeparator, $floatCurrencySymbolRight) {
        try {
            if ($value !== undefined && isNaN($value) === false) {
                this.value = $value.toString();
                $decimalNumbers = parseInt($decimalNumbers.toString(), undefined);
                if ($value < 0) {
                    // value is negative
                    /** @type {?} */
                    const v = parseFloat($value.toString().replace(/\-/g, ''));
                    /** @type {?} */
                    const $aux = this.formatter.formatNumber(v, $decimalNumbers, $thousandSeparator, $decimalSeparator);
                    if ($floatCurrencySymbolRight) {
                        this.value = '-' + $aux + $currencySymbol;
                    }
                    else {
                        this.value = '-' + $currencySymbol + $aux;
                    }
                }
                else {
                    this.value =
                        $currencySymbol +
                            this.formatter.formatNumber($value, $decimalNumbers, $thousandSeparator, $decimalSeparator);
                }
            }
            else {
                this.value = '';
            }
        }
        catch ($exception) {
            console.error('Value trying to transform: ', $value);
            console.error($exception);
            this.value = '';
        }
        return this.value;
    }
}
CmxCurrencyCustomPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxCurrencyCustom',
                pure: true
            },] }
];
/** @nocollapse */
CmxCurrencyCustomPipe.ctorParameters = () => [
    { type: FormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxCurrencyPipe {
    /**
     * @param {?} formatter
     * @param {?} translation
     * @param {?} platformId
     */
    constructor(formatter, translation, platformId) {
        this.formatter = formatter;
        this.translation = translation;
        this.platformId = platformId;
        if (isPlatformBrowser(platformId)) {
            this.window = window;
        }
    }
    /**
     * @param {?} value
     * @param {?=} countryCode
     * @return {?}
     */
    transform(value, countryCode) {
        if (value === '' || value == null || isNaN((/** @type {?} */ (value)))) {
            console.warn('The value is not a number');
            return '';
        }
        countryCode = countryCode || this.window.sessionStorage.getItem('country');
        // tslint:disable-next-line:triple-equals
        if (countryCode == undefined) {
            console.warn(`Can't retrieve countryCode`);
            return '';
        }
        /** @type {?} */
        const lang = this.translation.getLanguageByCountryCode(countryCode);
        /** @type {?} */
        const symbolPosition = (lang.currencySymbolFloat && lang.currencySymbolFloat.toLowerCase()) ||
            'left';
        /** @type {?} */
        const currencySymbol = lang.currencySymbol || '$';
        /** @type {?} */
        const formattedNumber = this.formatter.formatNumber(value, lang && lang.decimalNumbersMoney, lang && lang.thousandSeparator, lang && lang.decimalSeparator);
        /** @type {?} */
        const numberWithCurrency = symbolPosition === 'left'
            ? `${currencySymbol}${formattedNumber}`
            : `${formattedNumber}${currencySymbol}`;
        return '&lrm;' + numberWithCurrency;
    }
}
CmxCurrencyPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxCurrency',
                pure: true
            },] }
];
/** @nocollapse */
CmxCurrencyPipe.ctorParameters = () => [
    { type: FormatterService },
    { type: TranslationService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxDateMomentPipe {
    /**
     * @param {?} translationService
     * @param {?} formatterService
     */
    constructor(translationService, formatterService) {
        this.translationService = translationService;
        this.formatterService = formatterService;
    }
    /**
     * @param {?} dateTime
     * @param {?=} action
     * @return {?}
     */
    transform(dateTime, action = DateTimeActions.ConvertToLocal) {
        return this.formatterService.formatDateTimeMoment(dateTime, this.translationService.selectedLanguage.languageISO.replace('_', '-'), this.translationService.selectedLanguage.formatDate, action);
    }
}
CmxDateMomentPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxDateMoment',
                pure: false
            },] }
];
/** @nocollapse */
CmxDateMomentPipe.ctorParameters = () => [
    { type: TranslationService },
    { type: FormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateFormatterService {
    constructor() {
        //
    }
    /**
     * \@description Formats a date object to a string given a date format from a language
     * @param {?} $value
     * @param {?} $format
     * @param {?} $daysNames
     * @param {?} $monthsNames
     * @return {?} String of the formatted date
     */
    format($value, $format, $daysNames, $monthsNames) {
        /** @type {?} */
        let dateAsString = '';
        /** @type {?} */
        let $separator = '/';
        /** @type {?} */
        let day;
        /** @type {?} */
        let month;
        /** @type {?} */
        let year;
        /** @type {?} */
        let $formats = $format.split($separator);
        if ($formats.length === 1) {
            $separator = '-';
            $formats = $format.split($separator);
        }
        if ($formats.length === 1) {
            $separator = ' ';
            $formats = $format.split($separator);
        }
        if ($formats.length === 1) {
            $separator = '.';
            $formats = $format.split($separator);
        }
        $formats.forEach((/**
         * @param {?} $formatItem
         * @param {?} $index
         * @return {?}
         */
        ($formatItem, $index) => {
            /** @type {?} */
            const $auxValue = $value;
            /** @type {?} */
            const $formatCode = $formatItem.replace(',', '');
            if ($formatItem.includes('d') || $formatItem.includes('D')) {
                day = this.getDay($auxValue, $formatCode, $daysNames);
                $formatItem = $formatItem.replace($formatCode, day);
            }
            else if ($formatItem.includes('m') || $formatItem.includes('M')) {
                month = this.getMonth($auxValue, $formatCode, $monthsNames);
                $formatItem = $formatItem.replace($formatCode, month);
            }
            else if ($formatItem.includes('y') || $formatItem.includes('Y')) {
                year = this.getYear($auxValue, $formatCode);
                $formatItem = $formatItem.replace($formatCode, year);
            }
            if ($index !== $formats.length - 1) {
                dateAsString += $formatItem + $separator;
            }
            else {
                dateAsString += $formatItem;
            }
        }));
        return dateAsString;
    }
    /**
     * \@description Transforms a valid string to a date object
     * @param {?} date The date as string
     * @return {?} A javascript date object
     */
    getDateObject(date) {
        try {
            /** @type {?} */
            const auxDate = date.replace(/-g/, '/');
            /** @type {?} */
            const bits = auxDate.split(/\D/);
            /** @type {?} */
            const month = parseInt(bits[1], undefined) - 1;
            if (bits.length === 3) {
                return new Date(bits[0], month, bits[2]);
            }
            else {
                return new Date(bits[0], month, bits[2], bits[3], bits[4], bits[5]);
            }
        }
        catch ($exception) {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} $number
     * @return {?}
     */
    addZero($number) {
        return $number < 10 ? '0' + $number : $number.toString();
    }
    /**
     * @private
     * @param {?} $date
     * @param {?} $format
     * @param {?} $daysNames
     * @return {?}
     */
    getDay($date, $format, $daysNames) {
        /** @type {?} */
        let day;
        if ($format.length === 4) {
            // requires the complete name of the day
            day = $daysNames[$date.getDay()];
        }
        else if ($format.length === 3) {
            // requires an abbreviation of the day's name
            day = $daysNames[$date.getDay()].substring(0, 3);
        }
        else if ($format.length === 2 || $format.length === 1) {
            // requires the value of the day
            day = this.addZero($date.getDate());
        }
        // check if names should use lower or uppercase
        if ($format === $format.toLowerCase()) {
            // the format uses d
            day = day.toLowerCase();
        }
        return day;
    }
    /**
     * @private
     * @param {?} $date
     * @param {?} $format
     * @param {?} $monthsNames
     * @return {?}
     */
    getMonth($date, $format, $monthsNames) {
        /** @type {?} */
        let month;
        if ($format.length === 4) {
            // requires the complete name of the month
            month = $monthsNames[$date.getMonth()];
        }
        else if ($format.length === 3) {
            // requires an abbreviation of the day's name
            month = $monthsNames[$date.getMonth()].substring(0, 3);
        }
        else if ($format.length === 2) {
            // requires the value of the day
            month = this.addZero($date.getMonth() + 1);
        }
        // check if names should use lower or uppercase
        if ($format === $format.toLowerCase()) {
            // the format uses d
            month = month.toLowerCase();
        }
        return month;
    }
    /**
     * @private
     * @param {?} $date
     * @param {?} $format
     * @return {?}
     */
    getYear($date, $format) {
        /** @type {?} */
        let year;
        if ($format.length === 4) {
            // requires the complete year
            year = '' + $date.getFullYear();
        }
        else {
            // requires only the last 2 numbers of the year value
            year = '' + $date.getFullYear();
            year = year.substring(2);
        }
        return year;
    }
}
DateFormatterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DateFormatterService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxDatePipe {
    /**
     * @param {?} translation
     * @param {?} dateFormatter
     */
    constructor(translation, dateFormatter) {
        this.translation = translation;
        this.dateFormatter = dateFormatter;
        this.value = '';
        this.monthsNames = [];
        this.daysNames = [];
    }
    /**
     * @param {?} $value
     * @param {?=} $countryCode
     * @return {?}
     */
    transform($value, $countryCode) {
        try {
            if (typeof $value === 'number') {
                $value = new Date($value);
            }
            if (typeof $value === 'string') {
                $value = this.dateFormatter.getDateObject($value);
            }
            if ($countryCode === undefined || $countryCode === null) {
                $countryCode = sessionStorage.getItem('country');
            }
            if ($value !== undefined && $value instanceof Date) {
                /** @type {?} */
                const $currentLanguage = localStorage.getItem('language');
                /** @type {?} */
                const $lang = this.translation.getLanguage($currentLanguage ? $currentLanguage : 'en_US');
                this.daysNames = $lang.dayNames.split(',');
                this.monthsNames = $lang.monthNames.split(',');
                this.value = this.dateFormatter.format($value, $lang.formatDate, this.daysNames, this.monthsNames);
            }
            else {
                console.error('Date trying to transform: ', $value);
                this.value = '';
            }
        }
        catch ($exception) {
            console.error('Date trying to transform: ', $value);
            console.error($exception);
            this.value = '';
        }
        return this.value;
    }
}
CmxDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxDate',
                pure: true
            },] }
];
/** @nocollapse */
CmxDatePipe.ctorParameters = () => [
    { type: TranslationService },
    { type: DateFormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxDateTimeMomentPipe {
    /**
     * @param {?} translationService
     * @param {?} formatterService
     */
    constructor(translationService, formatterService) {
        this.translationService = translationService;
        this.formatterService = formatterService;
    }
    /**
     * @param {?} dateTime
     * @param {?=} action
     * @return {?}
     */
    transform(dateTime, action = DateTimeActions.ConvertToLocal) {
        return this.formatterService.formatDateTimeMoment(dateTime, this.translationService.selectedLanguage.languageISO.replace('_', '-'), this.translationService.selectedLanguage.formatDate +
            ' ' +
            this.translationService.selectedLanguage.formatTime, action);
    }
}
CmxDateTimeMomentPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxDateTimeMoment',
                pure: false
            },] }
];
/** @nocollapse */
CmxDateTimeMomentPipe.ctorParameters = () => [
    { type: TranslationService },
    { type: FormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxNumberPipe {
    /**
     * @param {?} translationService
     * @param {?} formatterService
     */
    constructor(translationService, formatterService) {
        this.translationService = translationService;
        this.formatterService = formatterService;
    }
    /**
     * @param {?} numberEntry
     * @return {?}
     */
    transform(numberEntry) {
        return this.formatterService.formatNumberTS(numberEntry, this.translationService.selectedLanguage.languageISO.replace('_', '-'), this.translationService.selectedLanguage.decimalNumbers);
    }
}
CmxNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxNumber',
                pure: false
            },] }
];
/** @nocollapse */
CmxNumberPipe.ctorParameters = () => [
    { type: TranslationService },
    { type: FormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmxTimeMomentPipe {
    /**
     * @param {?} translationService
     * @param {?} formatterService
     */
    constructor(translationService, formatterService) {
        this.translationService = translationService;
        this.formatterService = formatterService;
    }
    /**
     * @param {?} dateTime
     * @param {?=} action
     * @return {?}
     */
    transform(dateTime, action = DateTimeActions.ConvertToLocal) {
        return this.formatterService.formatDateTimeMoment(dateTime, this.translationService.selectedLanguage.languageISO.replace('_', '-'), this.translationService.selectedLanguage.formatTime, action);
    }
}
CmxTimeMomentPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cmxTimeMoment',
                pure: false
            },] }
];
/** @nocollapse */
CmxTimeMomentPipe.ctorParameters = () => [
    { type: TranslationService },
    { type: FormatterService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AngularLocalizationModule {
}
AngularLocalizationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CmxCurrencyCustomPipe,
                    CmxCurrencyPipe,
                    CmxDateMomentPipe,
                    CmxDatePipe,
                    CmxDateTimeMomentPipe,
                    CmxNumberPipe,
                    CmxTimeMomentPipe
                ],
                exports: [
                    CmxCurrencyCustomPipe,
                    CmxCurrencyPipe,
                    CmxDateMomentPipe,
                    CmxDatePipe,
                    CmxDateTimeMomentPipe,
                    CmxNumberPipe,
                    CmxTimeMomentPipe
                ],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DirectionService {
    /**
     * @param {?} translation
     */
    constructor(translation) {
        this.translation = translation;
        this.direction$ = new Subject();
        this.rtl$ = new Subject();
        this.translation.getSelectedLanguage().subscribe((/**
         * @param {?} language
         * @return {?}
         */
        (language) => {
            this.direction$.next(language.direction);
            this.rtl$.next(language.rtl);
        }));
    }
    /**
     * @return {?}
     */
    getDirection() {
        return this.direction$.asObservable();
    }
    /**
     * @return {?}
     */
    getRTL() {
        return this.rtl$.asObservable();
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    getDirectionFor(languageCode) {
        /** @type {?} */
        const language = this.translation.getLanguage(languageCode.split(/[-_]/)[0]);
        this.direction$.next(language.dir);
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    getRtlFor(languageCode) {
        /** @type {?} */
        const language = this.translation.getLanguage(languageCode.split(/[-_]/)[0]);
        this.rtl$.next(language.rtl);
    }
}
DirectionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DirectionService.ctorParameters = () => [
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocaleService {
    constructor() {
        // empty
    }
    /**
     * @param {?} languageISO
     * @return {?}
     */
    getConfiguration(languageISO) {
        switch (languageISO) {
            case 'en':
                return {
                    hourShort: 'hr',
                    minuteShort: 'min',
                    monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec',
                    secondShort: 'sec',
                    weekdaysMin: 'Su,Mo,Tu,We,Th,Fr,Sa',
                    weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'
                };
            case 'es':
                return {
                    hourShort: 'hr',
                    minuteShort: 'min',
                    monthsShort: 'Ene,Feb,Mar,Abr,May,Jun,Jul,Ago,Sep,Oct,Nov,Dic',
                    secondShort: 'seg',
                    weekdaysMin: 'Do,Lu,Ma,Mi,Ju,Vi,Sá',
                    weekdaysShort: 'Dom,Lun,Mar,Mié,Jue,Vie,Sáb'
                };
            case 'fr':
                return {
                    hourShort: 'h',
                    minuteShort: 'min',
                    monthsShort: 'Janv,Févr,Mars,Avr,Mai,Juin,Juil,Août,Sept,Oct,Nov,Déc',
                    secondShort: 'sec',
                    weekdaysMin: 'Di,Lu,Ma,Me,Je,Ve,Sa',
                    weekdaysShort: 'Dim,Lun,Mar,Mer,Jeu,Ven,Sam'
                };
            case 'de':
                return {
                    hourShort: 'Std.',
                    minuteShort: 'Min.',
                    monthsShort: 'Jan,Febr,Mrz,Apr,Mai,Jun,Jul,Aug,Sept,Okt,Nov,Dez',
                    secondShort: 'Sekunde',
                    weekdaysMin: 'So,Mo,Di,Mi,Do,Fr,Sa',
                    weekdaysShort: 'So,Mo,Di,Mi,Do,Fr,Sa'
                };
            case 'he':
                return {
                    hourShort: 'שעה',
                    minuteShort: 'דקות',
                    monthsShort: 'ינו׳,פבר׳,מרץ,אפר׳,מאי,יוני,יולי,אוג׳,ספט׳,אוק׳,נוב׳,דצמ׳',
                    secondShort: 'שנייה',
                    weekdaysMin: 'א,ב,ג,ד,ה,ו,ש',
                    weekdaysShort: 'א׳,ב׳,ג׳,ד׳,ה׳,ו׳,ש׳'
                };
            case 'pl':
                return {
                    hourShort: 'h',
                    minuteShort: 'min',
                    monthsShort: 'Sty,Lut,Mar,Kwi,Maj,Cze,Lip,Sie,Wrz,Paź,Lis,Gru',
                    secondShort: 's',
                    weekdaysMin: 'Nd,Pn,Wt,Śr,Cz,Pt,So',
                    weekdaysShort: 'Ndz,Pon,Wt,Śr,Czw,Pt,Sob'
                };
            default:
                return {
                    hourShort: 'hr',
                    minuteShort: 'min',
                    monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec',
                    secondShort: 'sec',
                    weekdaysMin: 'Su,Mo,Tu,We,Th,Fr,Sa',
                    weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'
                };
        }
    }
}
LocaleService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LocaleService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslationResolver {
    /**
     * @param {?} translationService
     */
    constructor(translationService) {
        this.translationService = translationService;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    resolve(route, state) {
        return this.translationService.languageLoaded;
    }
}
TranslationResolver.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslationResolver.ctorParameters = () => [
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AngularLocalizationModule, DateTimeActions, FormatterService, TranslationService, DirectionService, LocaleService, DateFormatterService, CmxCurrencyCustomPipe, CmxCurrencyPipe, CmxDatePipe, CmxDateMomentPipe, CmxTimeMomentPipe, CmxDateTimeMomentPipe, CmxNumberPipe, TranslationResolver };

//# sourceMappingURL=cemex-core-angular-localization-v7.js.map