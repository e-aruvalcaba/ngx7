/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as moment_ from 'moment';
import { TranslationService } from './translation.service';
import fromExponential from './../fromExponential';
/** @type {?} */
var moment = moment_;
/** @enum {number} */
var DateTimeActions = {
    ConvertToLocal: 0,
    NoConvertToLocal: 1,
};
export { DateTimeActions };
DateTimeActions[DateTimeActions.ConvertToLocal] = 'ConvertToLocal';
DateTimeActions[DateTimeActions.NoConvertToLocal] = 'NoConvertToLocal';
var FormatterService = /** @class */ (function () {
    function FormatterService() {
    }
    // DATES
    /**
     * @description Transforms a valid string to a date object
     * @param date The date as string
     * @returns A javascript date object
     */
    // DATES
    /**
     * \@description Transforms a valid string to a date object
     * @param {?} date The date as string
     * @return {?} A javascript date object
     */
    FormatterService.prototype.getDateObject = 
    // DATES
    /**
     * \@description Transforms a valid string to a date object
     * @param {?} date The date as string
     * @return {?} A javascript date object
     */
    function (date) {
        try {
            /** @type {?} */
            var auxDate = date.replace(/-g/, '/');
            /** @type {?} */
            var bits = auxDate.split(/\D/);
            /** @type {?} */
            var month = parseInt(bits[1], undefined) - 1;
            if (bits.length === 3) {
                return new Date(bits[0], month, bits[2]);
            }
            else {
                return new Date(bits[0], month, bits[2], bits[3], bits[4], bits[5]);
            }
        }
        catch ($exception) {
            return undefined;
        }
    };
    /**
     * @param {?} date
     * @param {?} languageISO
     * @param {?} format
     * @param {?=} action
     * @return {?}
     */
    FormatterService.prototype.formatDateTimeMoment = /**
     * @param {?} date
     * @param {?} languageISO
     * @param {?} format
     * @param {?=} action
     * @return {?}
     */
    function (date, languageISO, format, action) {
        if (action === void 0) { action = DateTimeActions.ConvertToLocal; }
        if (TranslationService.currentLanguage) {
            moment.updateLocale(TranslationService.currentLanguage.languageISO.substr(0, 2), TranslationService.currentLanguage.momentConfig);
        }
        if (action === DateTimeActions.NoConvertToLocal) {
            return moment(date)
                .locale(languageISO.substr(0, 2))
                .format(format);
        }
        return this.utcToLocal(date)
            .locale(languageISO.substr(0, 2))
            .format(format);
    };
    /**
     * @description Format a number by TypeScript Number function
     * The static value '-u-nu-latn' is for always returns commons numbers '1,2,3,4,5,6,7,8,9,0'
     * @param numberEntry: value to format
     * @param languageISO: specifict language to format
     * @param decimalNumbers: quantity decimals to set in the format
     * @returns A value formatted
     */
    /**
     * \@description Format a number by TypeScript Number function
     * The static value '-u-nu-latn' is for always returns commons numbers '1,2,3,4,5,6,7,8,9,0'
     * @param {?} numberEntry
     * @param {?} languageISO
     * @param {?} decimalNumbers
     * @return {?} A value formatted
     */
    FormatterService.prototype.formatNumberTS = /**
     * \@description Format a number by TypeScript Number function
     * The static value '-u-nu-latn' is for always returns commons numbers '1,2,3,4,5,6,7,8,9,0'
     * @param {?} numberEntry
     * @param {?} languageISO
     * @param {?} decimalNumbers
     * @return {?} A value formatted
     */
    function (numberEntry, languageISO, decimalNumbers) {
        if (isNaN(numberEntry) || numberEntry === null) {
            return 0;
        }
        return Number(this.round(numberEntry, decimalNumbers).toFixed(decimalNumbers)).toLocaleString(languageISO + '-u-nu-latn', {
            minimumFractionDigits: numberEntry % 1 === 0 ? 0 : decimalNumbers
        });
    };
    /**
     * @param {?} dateEntry
     * @return {?}
     */
    FormatterService.prototype.utcToLocal = /**
     * @param {?} dateEntry
     * @return {?}
     */
    function (dateEntry) {
        return moment.utc(dateEntry).local();
    };
    /**
     * @param {?} date
     * @param {?=} format
     * @return {?}
     */
    FormatterService.prototype.localToUtc = /**
     * @param {?} date
     * @param {?=} format
     * @return {?}
     */
    function (date, format) {
        if (format !== undefined) {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format(format);
        }
        else {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format();
        }
    };
    // expected time '00:00:00'
    // expected time '00:00:00'
    /**
     * @param {?} time
     * @return {?}
     */
    FormatterService.prototype.timeToMinutes = 
    // expected time '00:00:00'
    /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        /** @type {?} */
        var timeSplit = time.split(':');
        /** @type {?} */
        var hours = +timeSplit[0];
        /** @type {?} */
        var minutes = +timeSplit[1];
        /** @type {?} */
        var seconds = +timeSplit[2];
        return hours * 60 + minutes + this.roundToDown(seconds / 60);
    };
    // NUMBERS
    /**
     * @description Formats a number as a currency preserving its precision.
     * In order the keep the precision the number must be passed as a string
     * @param value The number value to format
     * @param numberDecimals The number of decimals to use
     * @param thousandSeparator The string character to use when separating numbers
     * @param decimalSeparator The string character to use when separating the decimal and integer part
     * @returns The number as a currency string
     */
    // NUMBERS
    /**
     * \@description Formats a number as a currency preserving its precision.
     * In order the keep the precision the number must be passed as a string
     * @param {?} value The number value to format
     * @param {?=} numberDecimals The number of decimals to use
     * @param {?=} thousandSeparator The string character to use when separating numbers
     * @param {?=} decimalSeparator The string character to use when separating the decimal and integer part
     * @return {?} The number as a currency string
     */
    FormatterService.prototype.formatNumber = 
    // NUMBERS
    /**
     * \@description Formats a number as a currency preserving its precision.
     * In order the keep the precision the number must be passed as a string
     * @param {?} value The number value to format
     * @param {?=} numberDecimals The number of decimals to use
     * @param {?=} thousandSeparator The string character to use when separating numbers
     * @param {?=} decimalSeparator The string character to use when separating the decimal and integer part
     * @return {?} The number as a currency string
     */
    function (value, numberDecimals, thousandSeparator, decimalSeparator) {
        // tslint:disable-next-line: triple-equals
        if (value == undefined || value.toString() == '' || isNaN((/** @type {?} */ (value)))) {
            console.warn('Not a valid number to format');
            return '';
        }
        // tslint:disable-next-line:triple-equals
        numberDecimals = numberDecimals != undefined ? numberDecimals : 2;
        // tslint:disable-next-line:triple-equals
        thousandSeparator =
            thousandSeparator !== undefined ? thousandSeparator : ',';
        // tslint:disable-next-line:triple-equals
        decimalSeparator = decimalSeparator !== undefined ? decimalSeparator : '.';
        /** @type {?} */
        var completeNumber = fromExponential(value);
        /** @type {?} */
        var sign = value < 0 ? '-' : '';
        /** @type {?} */
        var absoluteValue = value < 0 ? completeNumber.split('-')[1] : completeNumber;
        /** @type {?} */
        var truncatedDecimalValue = absoluteValue.split('.')[1] &&
            absoluteValue.split('.')[1].slice(0, numberDecimals);
        /** @type {?} */
        var integerPart = absoluteValue.split('.')[0];
        /** @type {?} */
        var floatingPart = this.rightPad(truncatedDecimalValue, '0', numberDecimals);
        /** @type {?} */
        var formattedInteger = integerPart;
        if (Number(integerPart) >= 1000) {
            formattedInteger = integerPart.replace(/./g, (/**
             * @param {?} c
             * @param {?} i
             * @param {?} a
             * @return {?}
             */
            function (c, i, a) {
                return i && c !== decimalSeparator && (a.length - i) % 3 === 0
                    ? thousandSeparator + c
                    : c;
            }));
        }
        // tslint:disable-next-line:max-line-length
        /** @type {?} */
        var formattedNumber = "" + sign + formattedInteger + (floatingPart.length > 0 ? decimalSeparator : '') + floatingPart;
        return formattedNumber;
    };
    /**
     * @param {?} value
     * @param {?} decimals
     * @return {?}
     */
    FormatterService.prototype.round = /**
     * @param {?} value
     * @param {?} decimals
     * @return {?}
     */
    function (value, decimals) {
        /** @type {?} */
        var type = '';
        type = 'round';
        /** @type {?} */
        var valueDecimals = value % 1;
        if (valueDecimals !== 0.5) {
            return Number(Math[type](value + 'e' + decimals) + 'e-' + decimals);
        }
        else {
            return Number(value);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FormatterService.prototype.roundToDown = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return Math.floor(value);
    };
    // STRINGS
    // STRINGS
    /**
     * @param {?} value
     * @return {?}
     */
    FormatterService.prototype.removeFirstZeros = 
    // STRINGS
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.replace(/^0+/, '');
    };
    /**
     * @param {?} text
     * @param {?} wildcard
     * @param {?} length
     * @return {?}
     */
    FormatterService.prototype.pad = /**
     * @param {?} text
     * @param {?} wildcard
     * @param {?} length
     * @return {?}
     */
    function (text, wildcard, length) {
        /** @type {?} */
        var result = text;
        while (result.length < length) {
            result = wildcard + result;
        }
        return result;
    };
    /**
     * @description Fills up a string with the specified character appending it to the right till lenght is achieved
     * @param text String to add padding
     * @param wildcard Character that's gonne be repeated
     * @param lenght The desired length
     */
    /**
     * \@description Fills up a string with the specified character appending it to the right till lenght is achieved
     * @param {?} text String to add padding
     * @param {?} wildcard Character that's gonne be repeated
     * @param {?} length
     * @return {?}
     */
    FormatterService.prototype.rightPad = /**
     * \@description Fills up a string with the specified character appending it to the right till lenght is achieved
     * @param {?} text String to add padding
     * @param {?} wildcard Character that's gonne be repeated
     * @param {?} length
     * @return {?}
     */
    function (text, wildcard, length) {
        if (text === undefined || text === null || text === '') {
            return wildcard.repeat(length);
        }
        /** @type {?} */
        var str = text.toString();
        while (str.length < length) {
            str += wildcard;
        }
        return str;
    };
    /**
     * @param {?} measureUnit
     * @return {?}
     */
    FormatterService.prototype.formatMeasureUnit = /**
     * @param {?} measureUnit
     * @return {?}
     */
    function (measureUnit) {
        switch (measureUnit) {
            case 'YD3':
                return 'Yd³';
            case 'M3':
                return 'M³';
            default:
                return measureUnit;
        }
    };
    FormatterService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FormatterService.ctorParameters = function () { return []; };
    return FormatterService;
}());
export { FormatterService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2VtZXgtY29yZS9hbmd1bGFyLWxvY2FsaXphdGlvbi12Ny8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9mb3JtYXR0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUVsQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRCxPQUFPLGVBQWUsTUFBTSxzQkFBc0IsQ0FBQzs7SUFFN0MsTUFBTSxHQUFHLE9BQU87OztJQUdwQixpQkFBYztJQUNkLG1CQUFnQjs7Ozs7QUFHbEI7SUFFRTtJQUFlLENBQUM7SUFFaEIsUUFBUTtJQUVSOzs7O09BSUc7Ozs7Ozs7SUFDSSx3Q0FBYTs7Ozs7OztJQUFwQixVQUFxQixJQUFZO1FBQy9CLElBQUk7O2dCQUNJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUM7O2dCQUNqQyxJQUFJLEdBQVEsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7O2dCQUMvQixLQUFLLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDO1lBQzlDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3JCLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQztpQkFBTTtnQkFDTCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFD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VztRQUNsQyxRQUFRLFdBQVcsRUFBRTtZQUNuQixLQUFLLEtBQUs7Z0JBQ1IsT0FBTyxLQUFLLENBQUM7WUFDZixLQUFLLElBQUk7Z0JBQ1AsT0FBTyxJQUFJLENBQUM7WUFDZDtnQkFDRSxPQUFPLFdBQVcsQ0FBQztTQUN0QjtJQUNILENBQUM7O2dCQTdORixVQUFVOzs7O0lBOE5YLHVCQUFDO0NBQUEsQUE5TkQsSUE4TkM7U0E3TlksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQnO1xuXG5pbXBvcnQgeyBUcmFuc2xhdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyYW5zbGF0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IGZyb21FeHBvbmVudGlhbCBmcm9tICcuLy4uL2Zyb21FeHBvbmVudGlhbCc7XG5cbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbmV4cG9ydCBlbnVtIERhdGVUaW1lQWN0aW9ucyB7XG4gIENvbnZlcnRUb0xvY2FsLFxuICBOb0NvbnZlcnRUb0xvY2FsXG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGb3JtYXR0ZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8vIERBVEVTXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUcmFuc2Zvcm1zIGEgdmFsaWQgc3RyaW5nIHRvIGEgZGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgYXMgc3RyaW5nXG4gICAqIEByZXR1cm5zIEEgamF2YXNjcmlwdCBkYXRlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGdldERhdGVPYmplY3QoZGF0ZTogc3RyaW5nKTogRGF0ZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGF1eERhdGUgPSBkYXRlLnJlcGxhY2UoLy1nLywgJy8nKTtcbiAgICAgIGNvbnN0IGJpdHM6IGFueSA9IGF1eERhdGUuc3BsaXQoL1xcRC8pO1xuICAgICAgY29uc3QgbW9udGggPSBwYXJzZUludChiaXRzWzFdLCB1bmRlZmluZWQpIC0gMTtcbiAgICAgIGlmIChiaXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoYml0c1swXSwgbW9udGgsIGJpdHNbMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGJpdHNbMF0sIG1vbnRoLCBiaXRzWzJdLCBiaXRzWzNdLCBiaXRzWzRdLCBiaXRzWzVdKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoICgkZXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXREYXRlVGltZU1vbWVudChcbiAgICBkYXRlLFxuICAgIGxhbmd1YWdlSVNPLFxuICAgIGZvcm1hdCxcbiAgICBhY3Rpb246IERhdGVUaW1lQWN0aW9ucyA9IERhdGVUaW1lQWN0aW9ucy5Db252ZXJ0VG9Mb2NhbFxuICApIHtcbiAgICBpZiAoVHJhbnNsYXRpb25TZXJ2aWNlLmN1cnJlbnRMYW5ndWFnZSkge1xuICAgICAgbW9tZW50LnVwZGF0ZUxvY2FsZShcbiAgICAgICAgVHJhbnNsYXRpb25TZXJ2aWNlLmN1cnJlbnRMYW5ndWFnZS5sYW5ndWFnZUlTTy5zdWJzdHIoMCwgMiksXG4gICAgICAgIFRyYW5zbGF0aW9uU2VydmljZS5jdXJyZW50TGFuZ3VhZ2UubW9tZW50Q29uZmlnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24gPT09IERhdGVUaW1lQWN0aW9ucy5Ob0NvbnZlcnRUb0xvY2FsKSB7XG4gICAgICByZXR1cm4gbW9tZW50KGRhdGUpXG4gICAgICAgIC5sb2NhbGUobGFuZ3VhZ2VJU08uc3Vic3RyKDAsIDIpKVxuICAgICAgICAuZm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudXRjVG9Mb2NhbChkYXRlKVxuICAgICAgLmxvY2FsZShsYW5ndWFnZUlTTy5zdWJzdHIoMCwgMikpXG4gICAgICAuZm9ybWF0KGZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEZvcm1hdCBhIG51bWJlciBieSBUeXBlU2NyaXB0IE51bWJlciBmdW5jdGlvblxuICAgKiBUaGUgc3RhdGljIHZhbHVlICctdS1udS1sYXRuJyBpcyBmb3IgYWx3YXlzIHJldHVybnMgY29tbW9ucyBudW1iZXJzICcxLDIsMyw0LDUsNiw3LDgsOSwwJ1xuICAgKiBAcGFyYW0gbnVtYmVyRW50cnk6IHZhbHVlIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gbGFuZ3VhZ2VJU086IHNwZWNpZmljdCBsYW5ndWFnZSB0byBmb3JtYXRcbiAgICogQHBhcmFtIGRlY2ltYWxOdW1iZXJzOiBxdWFudGl0eSBkZWNpbWFscyB0byBzZXQgaW4gdGhlIGZvcm1hdFxuICAgKiBAcmV0dXJucyBBIHZhbHVlIGZvcm1hdHRlZFxuICAgKi9cbiAgcHVibGljIGZvcm1hdE51bWJlclRTKG51bWJlckVudHJ5LCBsYW5ndWFnZUlTTywgZGVjaW1hbE51bWJlcnMpIHtcbiAgICBpZiAoaXNOYU4obnVtYmVyRW50cnkpIHx8IG51bWJlckVudHJ5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gTnVtYmVyKFxuICAgICAgdGhpcy5yb3VuZChudW1iZXJFbnRyeSwgZGVjaW1hbE51bWJlcnMpLnRvRml4ZWQoZGVjaW1hbE51bWJlcnMpXG4gICAgKS50b0xvY2FsZVN0cmluZyhsYW5ndWFnZUlTTyArICctdS1udS1sYXRuJywge1xuICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1iZXJFbnRyeSAlIDEgPT09IDAgPyAwIDogZGVjaW1hbE51bWJlcnNcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1dGNUb0xvY2FsKGRhdGVFbnRyeSkge1xuICAgIHJldHVybiBtb21lbnQudXRjKGRhdGVFbnRyeSkubG9jYWwoKTtcbiAgfVxuXG4gIHB1YmxpYyBsb2NhbFRvVXRjKGRhdGUsIGZvcm1hdD86IGFueSkge1xuICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG1vbWVudChkYXRlLCAnWVlZWS1NTS1ERCBUSEg6bW06c3NaJylcbiAgICAgICAgLnV0YygpXG4gICAgICAgIC5mb3JtYXQoZm9ybWF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vbWVudChkYXRlLCAnWVlZWS1NTS1ERCBUSEg6bW06c3NaJylcbiAgICAgICAgLnV0YygpXG4gICAgICAgIC5mb3JtYXQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBlY3RlZCB0aW1lICcwMDowMDowMCdcbiAgcHVibGljIHRpbWVUb01pbnV0ZXModGltZSkge1xuICAgIGNvbnN0IHRpbWVTcGxpdCA9IHRpbWUuc3BsaXQoJzonKTtcblxuICAgIGNvbnN0IGhvdXJzID0gK3RpbWVTcGxpdFswXTtcbiAgICBjb25zdCBtaW51dGVzID0gK3RpbWVTcGxpdFsxXTtcbiAgICBjb25zdCBzZWNvbmRzID0gK3RpbWVTcGxpdFsyXTtcblxuICAgIHJldHVybiBob3VycyAqIDYwICsgbWludXRlcyArIHRoaXMucm91bmRUb0Rvd24oc2Vjb25kcyAvIDYwKTtcbiAgfVxuXG4gIC8vIE5VTUJFUlNcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEZvcm1hdHMgYSBudW1iZXIgYXMgYSBjdXJyZW5jeSBwcmVzZXJ2aW5nIGl0cyBwcmVjaXNpb24uXG4gICAqIEluIG9yZGVyIHRoZSBrZWVwIHRoZSBwcmVjaXNpb24gdGhlIG51bWJlciBtdXN0IGJlIHBhc3NlZCBhcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG51bWJlciB2YWx1ZSB0byBmb3JtYXRcbiAgICogQHBhcmFtIG51bWJlckRlY2ltYWxzIFRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdG8gdXNlXG4gICAqIEBwYXJhbSB0aG91c2FuZFNlcGFyYXRvciBUaGUgc3RyaW5nIGNoYXJhY3RlciB0byB1c2Ugd2hlbiBzZXBhcmF0aW5nIG51bWJlcnNcbiAgICogQHBhcmFtIGRlY2ltYWxTZXBhcmF0b3IgVGhlIHN0cmluZyBjaGFyYWN0ZXIgdG8gdXNlIHdoZW4gc2VwYXJhdGluZyB0aGUgZGVjaW1hbCBhbmQgaW50ZWdlciBwYXJ0XG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgYXMgYSBjdXJyZW5jeSBzdHJpbmdcbiAgICovXG4gIHB1YmxpYyBmb3JtYXROdW1iZXIoXG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZyxcbiAgICBudW1iZXJEZWNpbWFscz86IG51bWJlcixcbiAgICB0aG91c2FuZFNlcGFyYXRvcj86IHN0cmluZyxcbiAgICBkZWNpbWFsU2VwYXJhdG9yPzogc3RyaW5nXG4gICk6IHN0cmluZyB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiB0cmlwbGUtZXF1YWxzXG4gICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCB8fCB2YWx1ZS50b1N0cmluZygpID09ICcnIHx8IGlzTmFOKHZhbHVlIGFzIGFueSkpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm90IGEgdmFsaWQgbnVtYmVyIHRvIGZvcm1hdCcpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgbnVtYmVyRGVjaW1hbHMgPSBudW1iZXJEZWNpbWFscyAhPSB1bmRlZmluZWQgPyBudW1iZXJEZWNpbWFscyA6IDI7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICB0aG91c2FuZFNlcGFyYXRvciA9XG4gICAgICB0aG91c2FuZFNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gdGhvdXNhbmRTZXBhcmF0b3IgOiAnLCc7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICBkZWNpbWFsU2VwYXJhdG9yID0gZGVjaW1hbFNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFNlcGFyYXRvciA6ICcuJztcblxuICAgIGNvbnN0IGNvbXBsZXRlTnVtYmVyOiBzdHJpbmcgPSBmcm9tRXhwb25lbnRpYWwodmFsdWUpO1xuXG4gICAgY29uc3Qgc2lnbjogc3RyaW5nID0gdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgY29uc3QgYWJzb2x1dGVWYWx1ZTogc3RyaW5nID1cbiAgICAgIHZhbHVlIDwgMCA/IGNvbXBsZXRlTnVtYmVyLnNwbGl0KCctJylbMV0gOiBjb21wbGV0ZU51bWJlcjtcbiAgICBjb25zdCB0cnVuY2F0ZWREZWNpbWFsVmFsdWU6IHN0cmluZyA9XG4gICAgICBhYnNvbHV0ZVZhbHVlLnNwbGl0KCcuJylbMV0gJiZcbiAgICAgIGFic29sdXRlVmFsdWUuc3BsaXQoJy4nKVsxXS5zbGljZSgwLCBudW1iZXJEZWNpbWFscyk7XG5cbiAgICBjb25zdCBpbnRlZ2VyUGFydDogc3RyaW5nID0gYWJzb2x1dGVWYWx1ZS5zcGxpdCgnLicpWzBdO1xuICAgIGNvbnN0IGZsb2F0aW5nUGFydDogc3RyaW5nID0gdGhpcy5yaWdodFBhZChcbiAgICAgIHRydW5jYXRlZERlY2ltYWxWYWx1ZSxcbiAgICAgICcwJyxcbiAgICAgIG51bWJlckRlY2ltYWxzXG4gICAgKTtcblxuICAgIGxldCBmb3JtYXR0ZWRJbnRlZ2VyOiBzdHJpbmcgPSBpbnRlZ2VyUGFydDtcblxuICAgIGlmIChOdW1iZXIoaW50ZWdlclBhcnQpID49IDEwMDApIHtcbiAgICAgIGZvcm1hdHRlZEludGVnZXIgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKC8uL2csIChjLCBpLCBhKSA9PiB7XG4gICAgICAgIHJldHVybiBpICYmIGMgIT09IGRlY2ltYWxTZXBhcmF0b3IgJiYgKGEubGVuZ3RoIC0gaSkgJSAzID09PSAwXG4gICAgICAgICAgPyB0aG91c2FuZFNlcGFyYXRvciArIGNcbiAgICAgICAgICA6IGM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgY29uc3QgZm9ybWF0dGVkTnVtYmVyID0gYCR7c2lnbn0ke2Zvcm1hdHRlZEludGVnZXJ9JHtcbiAgICAgIGZsb2F0aW5nUGFydC5sZW5ndGggPiAwID8gZGVjaW1hbFNlcGFyYXRvciA6ICcnXG4gICAgfSR7ZmxvYXRpbmdQYXJ0fWA7XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyO1xuICB9XG5cbiAgcHVibGljIHJvdW5kKHZhbHVlOiBudW1iZXIsIGRlY2ltYWxzOiBudW1iZXIpIHtcbiAgICBsZXQgdHlwZSA9ICcnO1xuICAgIHR5cGUgPSAncm91bmQnO1xuICAgIGNvbnN0IHZhbHVlRGVjaW1hbHMgPSB2YWx1ZSAlIDE7XG4gICAgaWYgKHZhbHVlRGVjaW1hbHMgIT09IDAuNSkge1xuICAgICAgcmV0dXJuIE51bWJlcihNYXRoW3R5cGVdKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJvdW5kVG9Eb3duKHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTVFJJTkdTXG4gIHB1YmxpYyByZW1vdmVGaXJzdFplcm9zKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eMCsvLCAnJyk7XG4gIH1cblxuICBwdWJsaWMgcGFkKHRleHQ6IHN0cmluZywgd2lsZGNhcmQ6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSB0ZXh0O1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSB3aWxkY2FyZCArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gRmlsbHMgdXAgYSBzdHJpbmcgd2l0aCB0aGUgc3BlY2lmaWVkIGNoYXJhY3RlciBhcHBlbmRpbmcgaXQgdG8gdGhlIHJpZ2h0IHRpbGwgbGVuZ2h0IGlzIGFjaGlldmVkXG4gICAqIEBwYXJhbSB0ZXh0IFN0cmluZyB0byBhZGQgcGFkZGluZ1xuICAgKiBAcGFyYW0gd2lsZGNhcmQgQ2hhcmFjdGVyIHRoYXQncyBnb25uZSBiZSByZXBlYXRlZFxuICAgKiBAcGFyYW0gbGVuZ2h0IFRoZSBkZXNpcmVkIGxlbmd0aFxuICAgKi9cbiAgcHVibGljIHJpZ2h0UGFkKFxuICAgIHRleHQ6IG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB3aWxkY2FyZDogc3RyaW5nLFxuICAgIGxlbmd0aDogbnVtYmVyXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09ICcnKSB7XG4gICAgICByZXR1cm4gd2lsZGNhcmQucmVwZWF0KGxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIHN0ciArPSB3aWxkY2FyZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcHVibGljIGZvcm1hdE1lYXN1cmVVbml0KG1lYXN1cmVVbml0KSB7XG4gICAgc3dpdGNoIChtZWFzdXJlVW5pdCkge1xuICAgICAgY2FzZSAnWUQzJzpcbiAgICAgICAgcmV0dXJuICdZZMKzJztcbiAgICAgIGNhc2UgJ00zJzpcbiAgICAgICAgcmV0dXJuICdNwrMnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVVbml0O1xuICAgIH1cbiAgfVxufVxuIl19