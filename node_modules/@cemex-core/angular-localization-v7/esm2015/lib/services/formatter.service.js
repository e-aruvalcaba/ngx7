/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as moment_ from 'moment';
import { TranslationService } from './translation.service';
import fromExponential from './../fromExponential';
/** @type {?} */
const moment = moment_;
/** @enum {number} */
const DateTimeActions = {
    ConvertToLocal: 0,
    NoConvertToLocal: 1,
};
export { DateTimeActions };
DateTimeActions[DateTimeActions.ConvertToLocal] = 'ConvertToLocal';
DateTimeActions[DateTimeActions.NoConvertToLocal] = 'NoConvertToLocal';
export class FormatterService {
    constructor() { }
    // DATES
    /**
     * \@description Transforms a valid string to a date object
     * @param {?} date The date as string
     * @return {?} A javascript date object
     */
    getDateObject(date) {
        try {
            /** @type {?} */
            const auxDate = date.replace(/-g/, '/');
            /** @type {?} */
            const bits = auxDate.split(/\D/);
            /** @type {?} */
            const month = parseInt(bits[1], undefined) - 1;
            if (bits.length === 3) {
                return new Date(bits[0], month, bits[2]);
            }
            else {
                return new Date(bits[0], month, bits[2], bits[3], bits[4], bits[5]);
            }
        }
        catch ($exception) {
            return undefined;
        }
    }
    /**
     * @param {?} date
     * @param {?} languageISO
     * @param {?} format
     * @param {?=} action
     * @return {?}
     */
    formatDateTimeMoment(date, languageISO, format, action = DateTimeActions.ConvertToLocal) {
        if (TranslationService.currentLanguage) {
            moment.updateLocale(TranslationService.currentLanguage.languageISO.substr(0, 2), TranslationService.currentLanguage.momentConfig);
        }
        if (action === DateTimeActions.NoConvertToLocal) {
            return moment(date)
                .locale(languageISO.substr(0, 2))
                .format(format);
        }
        return this.utcToLocal(date)
            .locale(languageISO.substr(0, 2))
            .format(format);
    }
    /**
     * \@description Format a number by TypeScript Number function
     * The static value '-u-nu-latn' is for always returns commons numbers '1,2,3,4,5,6,7,8,9,0'
     * @param {?} numberEntry
     * @param {?} languageISO
     * @param {?} decimalNumbers
     * @return {?} A value formatted
     */
    formatNumberTS(numberEntry, languageISO, decimalNumbers) {
        if (isNaN(numberEntry) || numberEntry === null) {
            return 0;
        }
        return Number(this.round(numberEntry, decimalNumbers).toFixed(decimalNumbers)).toLocaleString(languageISO + '-u-nu-latn', {
            minimumFractionDigits: numberEntry % 1 === 0 ? 0 : decimalNumbers
        });
    }
    /**
     * @param {?} dateEntry
     * @return {?}
     */
    utcToLocal(dateEntry) {
        return moment.utc(dateEntry).local();
    }
    /**
     * @param {?} date
     * @param {?=} format
     * @return {?}
     */
    localToUtc(date, format) {
        if (format !== undefined) {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format(format);
        }
        else {
            return moment(date, 'YYYY-MM-DD THH:mm:ssZ')
                .utc()
                .format();
        }
    }
    // expected time '00:00:00'
    /**
     * @param {?} time
     * @return {?}
     */
    timeToMinutes(time) {
        /** @type {?} */
        const timeSplit = time.split(':');
        /** @type {?} */
        const hours = +timeSplit[0];
        /** @type {?} */
        const minutes = +timeSplit[1];
        /** @type {?} */
        const seconds = +timeSplit[2];
        return hours * 60 + minutes + this.roundToDown(seconds / 60);
    }
    // NUMBERS
    /**
     * \@description Formats a number as a currency preserving its precision.
     * In order the keep the precision the number must be passed as a string
     * @param {?} value The number value to format
     * @param {?=} numberDecimals The number of decimals to use
     * @param {?=} thousandSeparator The string character to use when separating numbers
     * @param {?=} decimalSeparator The string character to use when separating the decimal and integer part
     * @return {?} The number as a currency string
     */
    formatNumber(value, numberDecimals, thousandSeparator, decimalSeparator) {
        // tslint:disable-next-line: triple-equals
        if (value == undefined || value.toString() == '' || isNaN((/** @type {?} */ (value)))) {
            console.warn('Not a valid number to format');
            return '';
        }
        // tslint:disable-next-line:triple-equals
        numberDecimals = numberDecimals != undefined ? numberDecimals : 2;
        // tslint:disable-next-line:triple-equals
        thousandSeparator =
            thousandSeparator !== undefined ? thousandSeparator : ',';
        // tslint:disable-next-line:triple-equals
        decimalSeparator = decimalSeparator !== undefined ? decimalSeparator : '.';
        /** @type {?} */
        const completeNumber = fromExponential(value);
        /** @type {?} */
        const sign = value < 0 ? '-' : '';
        /** @type {?} */
        const absoluteValue = value < 0 ? completeNumber.split('-')[1] : completeNumber;
        /** @type {?} */
        const truncatedDecimalValue = absoluteValue.split('.')[1] &&
            absoluteValue.split('.')[1].slice(0, numberDecimals);
        /** @type {?} */
        const integerPart = absoluteValue.split('.')[0];
        /** @type {?} */
        const floatingPart = this.rightPad(truncatedDecimalValue, '0', numberDecimals);
        /** @type {?} */
        let formattedInteger = integerPart;
        if (Number(integerPart) >= 1000) {
            formattedInteger = integerPart.replace(/./g, (/**
             * @param {?} c
             * @param {?} i
             * @param {?} a
             * @return {?}
             */
            (c, i, a) => {
                return i && c !== decimalSeparator && (a.length - i) % 3 === 0
                    ? thousandSeparator + c
                    : c;
            }));
        }
        // tslint:disable-next-line:max-line-length
        /** @type {?} */
        const formattedNumber = `${sign}${formattedInteger}${floatingPart.length > 0 ? decimalSeparator : ''}${floatingPart}`;
        return formattedNumber;
    }
    /**
     * @param {?} value
     * @param {?} decimals
     * @return {?}
     */
    round(value, decimals) {
        /** @type {?} */
        let type = '';
        type = 'round';
        /** @type {?} */
        const valueDecimals = value % 1;
        if (valueDecimals !== 0.5) {
            return Number(Math[type](value + 'e' + decimals) + 'e-' + decimals);
        }
        else {
            return Number(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    roundToDown(value) {
        return Math.floor(value);
    }
    // STRINGS
    /**
     * @param {?} value
     * @return {?}
     */
    removeFirstZeros(value) {
        return value.replace(/^0+/, '');
    }
    /**
     * @param {?} text
     * @param {?} wildcard
     * @param {?} length
     * @return {?}
     */
    pad(text, wildcard, length) {
        /** @type {?} */
        let result = text;
        while (result.length < length) {
            result = wildcard + result;
        }
        return result;
    }
    /**
     * \@description Fills up a string with the specified character appending it to the right till lenght is achieved
     * @param {?} text String to add padding
     * @param {?} wildcard Character that's gonne be repeated
     * @param {?} length
     * @return {?}
     */
    rightPad(text, wildcard, length) {
        if (text === undefined || text === null || text === '') {
            return wildcard.repeat(length);
        }
        /** @type {?} */
        let str = text.toString();
        while (str.length < length) {
            str += wildcard;
        }
        return str;
    }
    /**
     * @param {?} measureUnit
     * @return {?}
     */
    formatMeasureUnit(measureUnit) {
        switch (measureUnit) {
            case 'YD3':
                return 'Yd³';
            case 'M3':
                return 'M³';
            default:
                return measureUnit;
        }
    }
}
FormatterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FormatterService.ctorParameters = () => [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2VtZXgtY29yZS9hbmd1bGFyLWxvY2FsaXphdGlvbi12Ny8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9mb3JtYXR0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUVsQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRCxPQUFPLGVBQWUsTUFBTSxzQkFBc0IsQ0FBQzs7TUFFN0MsTUFBTSxHQUFHLE9BQU87OztJQUdwQixpQkFBYztJQUNkLG1CQUFnQjs7Ozs7QUFJbEIsTUFBTSxPQUFPLGdCQUFnQjtJQUMzQixnQkFBZSxDQUFDOzs7Ozs7O0lBU1QsYUFBYSxDQUFDLElBQVk7UUFDL0IsSUFBSTs7a0JBQ0ksT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQzs7a0JBQ2pDLElBQUksR0FBUSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQzs7a0JBQy9CLEtBQUssR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUM7WUFDOUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDckIsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzFDO2lCQUFNO2dCQUNMLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FB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S0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7Ozs7OztJQUdNLGdCQUFnQixDQUFDLEtBQWE7UUFDbkMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNsQyxDQUFDOzs7Ozs7O0lBRU0sR0FBRyxDQUFDLElBQVksRUFBRSxRQUFnQixFQUFFLE1BQWM7O1lBQ25ELE1BQU0sR0FBRyxJQUFJO1FBQ2pCLE9BQU8sTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUU7WUFDN0IsTUFBTSxHQUFHLFFBQVEsR0FBRyxNQUFNLENBQUM7U0FDNUI7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOzs7Ozs7OztJQVFNLFFBQVEsQ0FDYixJQUFpQyxFQUNqQyxRQUFnQixFQUNoQixNQUFjO1FBRWQsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUUsRUFBRTtZQUN0RCxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEM7O1lBQ0csR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDekIsT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtZQUMxQixHQUFHLElBQUksUUFBUSxDQUFDO1NBQ2pCO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDOzs7OztJQUVNLGlCQUFpQixDQUFDLFdBQVc7UUFDbEMsUUFBUSxXQUFXLEVBQUU7WUFDbkIsS0FBSyxLQUFLO2dCQUNSLE9BQU8sS0FBSyxDQUFDO1lBQ2YsS0FBSyxJQUFJO2dCQUNQLE9BQU8sSUFBSSxDQUFDO1lBQ2Q7Z0JBQ0UsT0FBTyxXQUFXLENBQUM7U0FDdEI7SUFDSCxDQUFDOzs7WUE3TkYsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50JztcblxuaW1wb3J0IHsgVHJhbnNsYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmFuc2xhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCBmcm9tRXhwb25lbnRpYWwgZnJvbSAnLi8uLi9mcm9tRXhwb25lbnRpYWwnO1xuXG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG5leHBvcnQgZW51bSBEYXRlVGltZUFjdGlvbnMge1xuICBDb252ZXJ0VG9Mb2NhbCxcbiAgTm9Db252ZXJ0VG9Mb2NhbFxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRm9ybWF0dGVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvLyBEQVRFU1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVHJhbnNmb3JtcyBhIHZhbGlkIHN0cmluZyB0byBhIGRhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIGFzIHN0cmluZ1xuICAgKiBAcmV0dXJucyBBIGphdmFzY3JpcHQgZGF0ZSBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBnZXREYXRlT2JqZWN0KGRhdGU6IHN0cmluZyk6IERhdGUge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhdXhEYXRlID0gZGF0ZS5yZXBsYWNlKC8tZy8sICcvJyk7XG4gICAgICBjb25zdCBiaXRzOiBhbnkgPSBhdXhEYXRlLnNwbGl0KC9cXEQvKTtcbiAgICAgIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQoYml0c1sxXSwgdW5kZWZpbmVkKSAtIDE7XG4gICAgICBpZiAoYml0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGJpdHNbMF0sIG1vbnRoLCBiaXRzWzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShiaXRzWzBdLCBtb250aCwgYml0c1syXSwgYml0c1szXSwgYml0c1s0XSwgYml0c1s1XSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoJGV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0RGF0ZVRpbWVNb21lbnQoXG4gICAgZGF0ZSxcbiAgICBsYW5ndWFnZUlTTyxcbiAgICBmb3JtYXQsXG4gICAgYWN0aW9uOiBEYXRlVGltZUFjdGlvbnMgPSBEYXRlVGltZUFjdGlvbnMuQ29udmVydFRvTG9jYWxcbiAgKSB7XG4gICAgaWYgKFRyYW5zbGF0aW9uU2VydmljZS5jdXJyZW50TGFuZ3VhZ2UpIHtcbiAgICAgIG1vbWVudC51cGRhdGVMb2NhbGUoXG4gICAgICAgIFRyYW5zbGF0aW9uU2VydmljZS5jdXJyZW50TGFuZ3VhZ2UubGFuZ3VhZ2VJU08uc3Vic3RyKDAsIDIpLFxuICAgICAgICBUcmFuc2xhdGlvblNlcnZpY2UuY3VycmVudExhbmd1YWdlLm1vbWVudENvbmZpZ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uID09PSBEYXRlVGltZUFjdGlvbnMuTm9Db252ZXJ0VG9Mb2NhbCkge1xuICAgICAgcmV0dXJuIG1vbWVudChkYXRlKVxuICAgICAgICAubG9jYWxlKGxhbmd1YWdlSVNPLnN1YnN0cigwLCAyKSlcbiAgICAgICAgLmZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnV0Y1RvTG9jYWwoZGF0ZSlcbiAgICAgIC5sb2NhbGUobGFuZ3VhZ2VJU08uc3Vic3RyKDAsIDIpKVxuICAgICAgLmZvcm1hdChmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBGb3JtYXQgYSBudW1iZXIgYnkgVHlwZVNjcmlwdCBOdW1iZXIgZnVuY3Rpb25cbiAgICogVGhlIHN0YXRpYyB2YWx1ZSAnLXUtbnUtbGF0bicgaXMgZm9yIGFsd2F5cyByZXR1cm5zIGNvbW1vbnMgbnVtYmVycyAnMSwyLDMsNCw1LDYsNyw4LDksMCdcbiAgICogQHBhcmFtIG51bWJlckVudHJ5OiB2YWx1ZSB0byBmb3JtYXRcbiAgICogQHBhcmFtIGxhbmd1YWdlSVNPOiBzcGVjaWZpY3QgbGFuZ3VhZ2UgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBkZWNpbWFsTnVtYmVyczogcXVhbnRpdHkgZGVjaW1hbHMgdG8gc2V0IGluIHRoZSBmb3JtYXRcbiAgICogQHJldHVybnMgQSB2YWx1ZSBmb3JtYXR0ZWRcbiAgICovXG4gIHB1YmxpYyBmb3JtYXROdW1iZXJUUyhudW1iZXJFbnRyeSwgbGFuZ3VhZ2VJU08sIGRlY2ltYWxOdW1iZXJzKSB7XG4gICAgaWYgKGlzTmFOKG51bWJlckVudHJ5KSB8fCBudW1iZXJFbnRyeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihcbiAgICAgIHRoaXMucm91bmQobnVtYmVyRW50cnksIGRlY2ltYWxOdW1iZXJzKS50b0ZpeGVkKGRlY2ltYWxOdW1iZXJzKVxuICAgICkudG9Mb2NhbGVTdHJpbmcobGFuZ3VhZ2VJU08gKyAnLXUtbnUtbGF0bicsIHtcbiAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtYmVyRW50cnkgJSAxID09PSAwID8gMCA6IGRlY2ltYWxOdW1iZXJzXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdXRjVG9Mb2NhbChkYXRlRW50cnkpIHtcbiAgICByZXR1cm4gbW9tZW50LnV0YyhkYXRlRW50cnkpLmxvY2FsKCk7XG4gIH1cblxuICBwdWJsaWMgbG9jYWxUb1V0YyhkYXRlLCBmb3JtYXQ/OiBhbnkpIHtcbiAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtb21lbnQoZGF0ZSwgJ1lZWVktTU0tREQgVEhIOm1tOnNzWicpXG4gICAgICAgIC51dGMoKVxuICAgICAgICAuZm9ybWF0KGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb21lbnQoZGF0ZSwgJ1lZWVktTU0tREQgVEhIOm1tOnNzWicpXG4gICAgICAgIC51dGMoKVxuICAgICAgICAuZm9ybWF0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwZWN0ZWQgdGltZSAnMDA6MDA6MDAnXG4gIHB1YmxpYyB0aW1lVG9NaW51dGVzKHRpbWUpIHtcbiAgICBjb25zdCB0aW1lU3BsaXQgPSB0aW1lLnNwbGl0KCc6Jyk7XG5cbiAgICBjb25zdCBob3VycyA9ICt0aW1lU3BsaXRbMF07XG4gICAgY29uc3QgbWludXRlcyA9ICt0aW1lU3BsaXRbMV07XG4gICAgY29uc3Qgc2Vjb25kcyA9ICt0aW1lU3BsaXRbMl07XG5cbiAgICByZXR1cm4gaG91cnMgKiA2MCArIG1pbnV0ZXMgKyB0aGlzLnJvdW5kVG9Eb3duKHNlY29uZHMgLyA2MCk7XG4gIH1cblxuICAvLyBOVU1CRVJTXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBGb3JtYXRzIGEgbnVtYmVyIGFzIGEgY3VycmVuY3kgcHJlc2VydmluZyBpdHMgcHJlY2lzaW9uLlxuICAgKiBJbiBvcmRlciB0aGUga2VlcCB0aGUgcHJlY2lzaW9uIHRoZSBudW1iZXIgbXVzdCBiZSBwYXNzZWQgYXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdmFsdWUgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBudW1iZXJEZWNpbWFscyBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHVzZVxuICAgKiBAcGFyYW0gdGhvdXNhbmRTZXBhcmF0b3IgVGhlIHN0cmluZyBjaGFyYWN0ZXIgdG8gdXNlIHdoZW4gc2VwYXJhdGluZyBudW1iZXJzXG4gICAqIEBwYXJhbSBkZWNpbWFsU2VwYXJhdG9yIFRoZSBzdHJpbmcgY2hhcmFjdGVyIHRvIHVzZSB3aGVuIHNlcGFyYXRpbmcgdGhlIGRlY2ltYWwgYW5kIGludGVnZXIgcGFydFxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIGFzIGEgY3VycmVuY3kgc3RyaW5nXG4gICAqL1xuICBwdWJsaWMgZm9ybWF0TnVtYmVyKFxuICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsXG4gICAgbnVtYmVyRGVjaW1hbHM/OiBudW1iZXIsXG4gICAgdGhvdXNhbmRTZXBhcmF0b3I/OiBzdHJpbmcsXG4gICAgZGVjaW1hbFNlcGFyYXRvcj86IHN0cmluZ1xuICApOiBzdHJpbmcge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdHJpcGxlLWVxdWFsc1xuICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQgfHwgdmFsdWUudG9TdHJpbmcoKSA9PSAnJyB8fCBpc05hTih2YWx1ZSBhcyBhbnkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vdCBhIHZhbGlkIG51bWJlciB0byBmb3JtYXQnKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgIG51bWJlckRlY2ltYWxzID0gbnVtYmVyRGVjaW1hbHMgIT0gdW5kZWZpbmVkID8gbnVtYmVyRGVjaW1hbHMgOiAyO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgdGhvdXNhbmRTZXBhcmF0b3IgPVxuICAgICAgdGhvdXNhbmRTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHRob3VzYW5kU2VwYXJhdG9yIDogJywnO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxTZXBhcmF0b3IgOiAnLic7XG5cbiAgICBjb25zdCBjb21wbGV0ZU51bWJlcjogc3RyaW5nID0gZnJvbUV4cG9uZW50aWFsKHZhbHVlKTtcblxuICAgIGNvbnN0IHNpZ246IHN0cmluZyA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgIGNvbnN0IGFic29sdXRlVmFsdWU6IHN0cmluZyA9XG4gICAgICB2YWx1ZSA8IDAgPyBjb21wbGV0ZU51bWJlci5zcGxpdCgnLScpWzFdIDogY29tcGxldGVOdW1iZXI7XG4gICAgY29uc3QgdHJ1bmNhdGVkRGVjaW1hbFZhbHVlOiBzdHJpbmcgPVxuICAgICAgYWJzb2x1dGVWYWx1ZS5zcGxpdCgnLicpWzFdICYmXG4gICAgICBhYnNvbHV0ZVZhbHVlLnNwbGl0KCcuJylbMV0uc2xpY2UoMCwgbnVtYmVyRGVjaW1hbHMpO1xuXG4gICAgY29uc3QgaW50ZWdlclBhcnQ6IHN0cmluZyA9IGFic29sdXRlVmFsdWUuc3BsaXQoJy4nKVswXTtcbiAgICBjb25zdCBmbG9hdGluZ1BhcnQ6IHN0cmluZyA9IHRoaXMucmlnaHRQYWQoXG4gICAgICB0cnVuY2F0ZWREZWNpbWFsVmFsdWUsXG4gICAgICAnMCcsXG4gICAgICBudW1iZXJEZWNpbWFsc1xuICAgICk7XG5cbiAgICBsZXQgZm9ybWF0dGVkSW50ZWdlcjogc3RyaW5nID0gaW50ZWdlclBhcnQ7XG5cbiAgICBpZiAoTnVtYmVyKGludGVnZXJQYXJ0KSA+PSAxMDAwKSB7XG4gICAgICBmb3JtYXR0ZWRJbnRlZ2VyID0gaW50ZWdlclBhcnQucmVwbGFjZSgvLi9nLCAoYywgaSwgYSkgPT4ge1xuICAgICAgICByZXR1cm4gaSAmJiBjICE9PSBkZWNpbWFsU2VwYXJhdG9yICYmIChhLmxlbmd0aCAtIGkpICUgMyA9PT0gMFxuICAgICAgICAgID8gdGhvdXNhbmRTZXBhcmF0b3IgKyBjXG4gICAgICAgICAgOiBjO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIGNvbnN0IGZvcm1hdHRlZE51bWJlciA9IGAke3NpZ259JHtmb3JtYXR0ZWRJbnRlZ2VyfSR7XG4gICAgICBmbG9hdGluZ1BhcnQubGVuZ3RoID4gMCA/IGRlY2ltYWxTZXBhcmF0b3IgOiAnJ1xuICAgIH0ke2Zsb2F0aW5nUGFydH1gO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlcjtcbiAgfVxuXG4gIHB1YmxpYyByb3VuZCh2YWx1ZTogbnVtYmVyLCBkZWNpbWFsczogbnVtYmVyKSB7XG4gICAgbGV0IHR5cGUgPSAnJztcbiAgICB0eXBlID0gJ3JvdW5kJztcbiAgICBjb25zdCB2YWx1ZURlY2ltYWxzID0gdmFsdWUgJSAxO1xuICAgIGlmICh2YWx1ZURlY2ltYWxzICE9PSAwLjUpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoTWF0aFt0eXBlXSh2YWx1ZSArICdlJyArIGRlY2ltYWxzKSArICdlLScgKyBkZWNpbWFscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByb3VuZFRvRG93bih2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU1RSSU5HU1xuICBwdWJsaWMgcmVtb3ZlRmlyc3RaZXJvcyh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXjArLywgJycpO1xuICB9XG5cbiAgcHVibGljIHBhZCh0ZXh0OiBzdHJpbmcsIHdpbGRjYXJkOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0ID0gdGV4dDtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gd2lsZGNhcmQgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEZpbGxzIHVwIGEgc3RyaW5nIHdpdGggdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXIgYXBwZW5kaW5nIGl0IHRvIHRoZSByaWdodCB0aWxsIGxlbmdodCBpcyBhY2hpZXZlZFxuICAgKiBAcGFyYW0gdGV4dCBTdHJpbmcgdG8gYWRkIHBhZGRpbmdcbiAgICogQHBhcmFtIHdpbGRjYXJkIENoYXJhY3RlciB0aGF0J3MgZ29ubmUgYmUgcmVwZWF0ZWRcbiAgICogQHBhcmFtIGxlbmdodCBUaGUgZGVzaXJlZCBsZW5ndGhcbiAgICovXG4gIHB1YmxpYyByaWdodFBhZChcbiAgICB0ZXh0OiBudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgd2lsZGNhcmQ6IHN0cmluZyxcbiAgICBsZW5ndGg6IG51bWJlclxuICApOiBzdHJpbmcge1xuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSAnJykge1xuICAgICAgcmV0dXJuIHdpbGRjYXJkLnJlcGVhdChsZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgc3RyID0gdGV4dC50b1N0cmluZygpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBzdHIgKz0gd2lsZGNhcmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXRNZWFzdXJlVW5pdChtZWFzdXJlVW5pdCkge1xuICAgIHN3aXRjaCAobWVhc3VyZVVuaXQpIHtcbiAgICAgIGNhc2UgJ1lEMyc6XG4gICAgICAgIHJldHVybiAnWWTCsyc7XG4gICAgICBjYXNlICdNMyc6XG4gICAgICAgIHJldHVybiAnTcKzJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBtZWFzdXJlVW5pdDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==